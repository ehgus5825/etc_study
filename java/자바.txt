------------------------------- 1단원 : Let's Start Java! --------------------------------
JDK : Java Developement Kit
eclipse : java IDE
JVM : Java Virtual machine

jdk 다운 -> 환경변수 설정 -> 사용

JVM이 운영체제 마다 다르기 때문에 자바프로그램은 운영체제의 차이와는 무관하게 작동시킬수 있음

자바 컴파일러는 자바 가상머신이 이해할 수 있는 코드를 생성(자바 바이트코드)
.java -> 자바컴파일러(자바 바이트코드로 변환) -> .class -> 실행

실행 키는 f11

------------------------------- 2단원 : 변수와 자료형 ----------------------------------

자바는 char이 2바이트다 unicode이기 때문에 long은 정수 8바이트

변수이름 : 숫자로 시작 X | $와 _이외의 다른 특수문자 사용 X | 키워드 사용 X

자바는 정수형 연산을  int형으로 진행 => int 사용 (저장할때 에러) 
long에서는 int형으로 진행하지 않음

------------------------------- 3단원 : 상수와 형 변환 ---------------------------------

상수로 만들 땐 const가 아닌 final (할당하지 않으면 한번은 할당 가능)

long의 리터럴을 long 변수에 담을려면 L이나 l을 붙여야함.. int로 생각해서 값이 너무 크다는 에러가 발생함

이진수 표현법 : 앞에 0b를 붙임 
언더바 사용 : 언더바를 넣어서 초기화 해도 언더바를 무시하고 값이 들어감

실수형 상수는 기본이 double이며 D(d)또는 F(f)를 붙여서 사용할 수 있음

\u => 유니코드 이스케이프 시퀀스

자동형변환 : (byte -> short), char -> int -> long -> float -> double

------------------------------- 4단원 : 연산자 ------------------------------------------

복합대입연산자를 사용하면 형변환을 할 필요가 없음..

관계연산자를 사용할때도 자동 형변환이 일어남..

------------------------------- 5단원 : 실행 흐름의 컨트롤 ---------------------------

반복문 중첩일때 한번에 나올수 있도록 outer을 설정할수 있음

------------------------------- 6단원 : 메소드와 변수의 스코프 ----------------------

------------------------------- 7단원 : 클래스와 인스턴스 ----------------------------

클래스 
- 데이터 + 메소드, 인스턴스화, 참조변수, 생성자(초기화)
- 클래스 이름 규칙 : camel case // ex) Circle + Point = CirclePoint
- 메소드와 변수 이름 규칙 : 변형된 camel case // ex) Your + Age = yourAge
- 상수의 이름 규칙 : 대문자 (+연결시 _언더바)

------------------------------- 8단원 : 패키지와 클래스 패스 -----------------------
클래스 패스 : 자바 가상머신이 클래스 파일을 찾는 경로
클래스 패스 설정 - set classpath= // => 일시적
클래스 패스 고정시키는 방법 : 환경변수 등록 => 좋은 방법은 아님

패키지 : 클래스들을 묶는 방법 / 이름 충돌 해소(접근방법의 구분 / 공간적인 구분)  / 패키지를 정하지 않으면 default 패키지임

클래스 파일 : 
package 패키지명 

클래스 { }

패키지 이름 규칙 : 이름 소문자 / 도메인 이름의 역순으로 이름 구성 / 팀구분하는 이름 추가 // ex) wxfx.com + smart팀 => com.wxfx.smart
상단에 패키지 선언 // ex) package com.wxfx.smart

컴파일시 현재 디렉토리 기준으로 패키지를 찾고 그안에서 class를 찾아서 인스턴스 생성

import는 불러와서 긴 이름을 생략하는 것에 사용 => 패키지 선언 생략
ex) import com.wxfx.smart.Circle; => 지금부터 Circle은 com.wxfx.smart.Circle을 의미한다. 
하지만 import의 사용은 이름 충돌이 일어날 수 있기 때문에 사용 자제..
*를 사용하면 모든 클래스를 다 줄여 쓰겠다는 말임

------------------------------- 9단원 : 정보 은닉 그리고 캡슐화 -----------------------

게터와 세터 : 
- 게터 : 인스턴스 변수의 값을 참조하는 용도로 정의된 메소드
- 세터 : 인스턴스 변수의 값을 설정하는 용도로 정의된 메소드

접근수준지시자 : public, private, protected, defalut
- 클래스 정의 대상 : public(어디서든), defalut(동일패키지)
- 인스턴스 변수와 메소드 대상 : public(어디서든), private(클래스 내), protected(동일 패키지 내의 상속+ 다른 패키지 내의 상속)
			    , defalut(동일패키지)

클래스의 public 선언과 관련하여 지켜야할 사항
- 하나의 소스파일에 하나의 클래스만 public
- 소스파일의 이름과 public으로 선언된 클래스의 이름을 일치시킴

------------------------- 10단원 : 클래스 변수와 클래스 메소드 ---------------------

static 변수 => 인스턴스 변수 X / 클래스 변수 O 
- 클래스의 모든 인스턴스가 공유하는 변수 / 어떠한 인스턴스에도 속하지 않음
- 클래스를 통한 접근, 인스턴스를 통한 접근
 - 클래스 변수는 인스턴스 생성 이전에 메모리 공간에 존재 => 생성자로 인한 초기화 X (=> 인스턴스 변수 초기화)
- 인스턴스 간에 데이터 공유가 필요한 상황에 클래스 변수 사용

static 메소드 => 인스턴스 메소드 X / 클래스 메소드 O
- 인스턴스 생성 이전부터 접근이 가능하다 / 어떠한 인스턴스에도 속하지 않음
-  클래스 메소드는 인스턴스에 속하지 않으므로 인스턴스 변수의 접근과 인스턴스 메소드의 호출도 불가능
- 인스턴스 메소드 => 클래스 변수, 메소드 사용 가능, 인스턴스 변수, 메소드 사용 가능
- 클래스 메소드 => 인스턴스 변수, 인스턴스 메소드 사용 X, 클래스 변수 사용 가능

import java.lang.*; 을 컴파일러가 삽입해주기 때문에 java.lang없이 System.out.println(); 사용 가능

main은 호출이 이뤄지는 영역이 외부이기 때문에 public / 인스턴스가 생성되기 전에 호출되기 때문에 static이다.

main 메소드는 static이기 때문에 특정 인스턴스의 멤버로 존재하지 않는다. 그래서 java파일의 아무 class 내에 위치해도 상관없다.

아무 클래스안의 main 메소드가 해당 클래스의 인스턴스를 생성하는 것이 난해하게 느껴지겠지만 해당 클래스와 static으로 선언된 main 
메소드는 사실상 별개이며 다만 해당클래스가 main 메소드에게 공간을 제공했을 뿐이다. 컴파일과 실행할 때 주체가 달리질 뿐

static +
- static 초기화 블록 : static { 클래스 로딩시 단 한번 실행 됨 } => 클래스 변수를 초기화 할때 사용됨
- static import 선언 : 원래 고정된 패키지를 손봐서 고정시킬 수 있음

---------------------- 11단원 : 메소드 오버로딩과 String 클래스 ---------------------

메소드 오버로딩 : 메소드를 다중정의 하는 것, 반환형은 기준이 아니다. / 생성자도 오버로딩의 대상이 된다.

this() => 생성자.. 새로 알게됨
this는 해당 클래스로 만들어진 현재 인스턴스 자체

String 인스턴스(리터럴)는 Immutable[변경할 수 없는] 인스턴스이다. 값에 대한 참조주소가 정해져있다.
switch case 문자열 사용 가능

없는 메소드는 자바 문서를 보고 참고하자!
문자열 비교 : equals()        / 같은지 비교
문자열 비교 : compareTo() / 사전순 비교 / compareToIgnoreCase() / 대소문자 구분 X
문자열 연결 : concat(String) / +
문자열 추출 : substring()
문자열 변환 : valueOf

대부분 파괴적 메소드 그리고 자기 자신을 리턴하기 떄문에 불필요한 인스턴스를 만들지 않음
StringBuilder 클래스 // 반환이 자기 주체 (참조 주소) (substring/toString 제외)
StringBuilder.append(int i)	: 기본자료형 추가
StringBuilder.delete(int start, int end)	: start부터 end까지 삭제
StringBuilder.insert(int offset, String str)  : 해당 인덱스에 str 추가
StringBuilder.replace(int start, int end, String str) : start부터 end까지를 str로 대체
StringBuilder.reverse()	: 문자열 내용 뒤집음
StringBuilder.substring(int start, int end) : start ~ end를 String 인스턴스로 생성
StringBuilder.toString()  : 저장된 것들을 String 인스턴스로 변환
생성자 StringBuilder() : 16개 문자 / StringBuilder(int) : int개의 문자 / StringBuilder("aaa") : 초기화와 16개 문자.

=> 불필요한 String을 만들지 않음

StringBuffer는 쓰레드에 안전하지만, StringBuilder는 쓰레드에 안전하지 않음
멀티쓰레드에 안전하게 설계된 StringBuffer 클래스는 속도가 느리다

------------------------------- 12단원 : 콘솔과 입출력 ---------------------------------

System.out.println은 참조값이 전달되면, 이 값의 인스턴스를 대상으로 toString 메소드를 호출한다. 그리고 이때 반환되는 문자열을 출력한다.

System.out.printf("서식지정자", 변수나 상수) => C언어에서 입*출력하는 방식 
( == System.out.format )

e 표기법 ex) 1.2*10^+15 => 1.2e+15 // 7.4*10^-20 => 7.4e-20

Scanner 클래스 : 입력을 받고 있다가 메소드 next~()를 통해서 공백마다 형변환하여 잘라서 줌.. 따라서 System.in과 함께 사용하여
사용자에게 입력을 받게 할 수 있음
+ import java.util.Scanner
Scanner(File [ String, InputStream ] source) 

Scanner sc = new Scanner(System.in);	// => 키보드 입력 받음
int num1 = sc.nextInt();		// => 입력 받고 변수에 저장 (개행이나 공백을 기준으로 입력)
int num2 = sc.nextInt();		//
int num3 = sc.nextInt();		//

int nextInt() / byte nextByte() / String nextLine() / double nextDouble() / boolean nextBoolean()

------------------------------------ 13단원 : 배열 ---------------------------------------

int[] ref      => int 형 1차원 배열 인스턴스를 참조할 수 있는 참조변수의 선언 (선호하는 방법) // ( = int ref[] )
new int[5]  => int형 값 5개를 저장할 수 있는 배열 인스턴스의 생성 
배열이 인스턴스인 이유 인스턴스 변수를 지님 ex) length

class Box { ... } Box[] ar = new Box[5] : 클래스를 자료형으로 배열 생성 가능 / 배열 인스턴스 값 하나하나가 Box 인스턴스임

반복문과 함께 사용하면 good

int[] arr = new int[] {1,2,3} => 선언과 동시에 초기화하기 위해서는 배열의 길이를 초깃값으로 계산할 수 있으므로 생략한다.
int[] arr = {1,2,3} => 위와 동일

배열도 참조변수를 매개변수로 메소드 호출 가능 // 메소드에서 반환도 가능 (선언 처럼 연결해주기만 하면 됨)

배열이 생성되면 모든요소는 0 또는 null로 초기화 됨 // int => 0 // String => null

+ import java.util.Arrays;

클래스 메소드
배열을 원하는 값으로 초기화하는 메소드 : Arrays.fill(배열, 첫, 끝-1, 값) // 첫, 끝 생략 가능		// Arrays 클래스 메소드

+ import java.lang.System => 생략

클래스 메소드
배열 복사 메소드 : System.arraycopy(원배열, 원본첫인덱스, 대상배열, 대상첫인덱스, 복사요소의수)	// System 클래스 메소드

main에 있는 Stiring [] args는 외부파일에서 구성된 배열이 인자로 들어옴 모든것은 가상머신이 하는 일이지만 String 배열을 
구성하는 것은 사용자가 전달하는것임 예를들면 cmd의 java를 실행할때 String을 이어 붙여주면 그 String들이 main의 인자로 들어감.

enhanced for 문 => for (요소 : 배열) { } // 배열에 속하는 모든 값을 돌때 사용 // 배열에 있는 요소를 하나씩 반복하면서 사용 가능 

2차원 배열 ex) int [][] arr = new int[3][4]; => 세로3, 가로4
초기화 방법 ex) int[][] arr = new int[][]{{1,2,3},{4,5,6},{7,8,9}}

----------------------- 14단원 : 클래스의 상속 : 상속의 기본 -------------------------

상속은 코드의 재활용을 목적으로 사용하는 문법이 아니다..!

기존에 정의된 클래스에 메소드와 변수를 추가하여 새로운 클래스를 정의하는 것이 상속이다. 부모의 변수와 메소드를 사용할 수 있음.

생성자로 초기화 해줄때 상위 클래스의 변수도 초기화 해주어야 한다.

하위 클래스의 인스턴스 생성 시 상위 클래스, 하위 클래스의 생성자 모두 호출된다.
하위 클래스의 인스턴스 생성 시 상위 클래스의 생성자가 먼저 호출된다. (최상위 클래스까지 탐색후 상위클래스 -> 하위클래스 순으로 호출)
상위 클래스의 생성자 호출 => super() 키워드 
- 사용하는 이유 상위 클래스의 인자가 없는 생성자가 자동호출 되기 때문에 상위클래스의 생성자로 상위클래스 멤버들을 초기화 해주기 위해
- 문법적으로 생성자 코드 내의 첫 문장으로 등장해야함.
- 상속 관계에 있을지라도 인스턴스 변수는 각 클래스의 생성자를 통해서 초기화 해야한다..!!

자바에서는 단일 상속만 지원.. 다중상속은 득보다 실이 더 많다 - 하나의 자식의 부모는 하나뿐이다. 하지만 부모는 여러 자식이 있을 수 있다.

클래스변수와 클래스 메소드는 상속의 대상이 아니다.
인스턴스에 속하지 않기 때문에 상속의 대상은 아니지만 클래스 변수나 메소드로는 접근이 가능하다.
상위클래스의 static 변수를 하위클래스가 변수 이름만으로 접근 가능한가? => 접근지시자만 허용한다면 가능하다.

----------------------- 15 단원 : 클래스의 상속 : 오버라이딩 -------------------------

IS-A 관계 :  A is a B -> A 은 B (의 파생)이다.
- 하위 클래스는 상위 클래스의 모든 특성을 지닌다.
- 거기에 더하여 하위 클래스는 자신만의 추가적인 특성을 더하게 된다.
- ex) 모바일폰 (부모) - 스마트폰 (자식)

상위 /클래스의 참조변수는 하위 클래스의 인스턴스를 참조할 수 있다. ex) 부모클래스 a = new 자식클래스();
=> class 자식클래스 extends 부모클래스 { ... } => 부모클래스를 상속하는 자식클래스 인스턴스는 자식클래스 
인스턴스인 동시에 부모클래스 인스턴스이기도하다.

=> 하지만 이처럼 인스턴스를 선언하게 되면 a를 통해서 접근 가능한 멤버는 부모클래스(자신)에 정의 되었거나
이 클래스가 상속받은 상위 클래스(조부모)의 멤버로 제한된다. 
=> 참조하는 인스턴스(new)에 따라서 접근가능한 멤버가 결정되아야 한다고 생각할 수 있지만 
그렇게 하지않는 이유는 2가지가 있다. (참조 변수의 형을 기준으로 접근 제한)

- 실행 시간을 늦추는 결과로 이어질 수 있다. (참조변수의 형을 참조하여 메소드 호출시 컴파일 단계에서 쉽게 판단 가능하여 빠르다)
- 참조변수의 형을 기준으로 접근 가능한 멤버를 제한하는 것은 코드를 단순하게 한다.

자식클래스 a = new 부모클래스(); 와 같이 반대로의 선언은 불가능하다. => 참조변수의 형만 가지고 대입의 가능성을 판단하기 때문
=> 명시적 형변환으로는 가능하다.(프로그래머의 선택, 컴파일러의 신뢰)  => 치명적인 실수를 포함할 수 있으니 권장 X
ex) 부모클래스 b = new 자식클래스() 
     자식클래스 a = (자식클래스)b

상속 관계에 있는 두 클래스의 참조 관계가 배열까지 이어진다.

메소드 오버라이딩 : 상위 클래스에 정의된 메소드를 하위 클래스에서 다시 정의하는 것을 뜻한다.
- 오버라이딩 : 무효화시키다.
- 메소드 이름, 메소드의 반환형, 메소드의 매개변수 -> 이 3가지가 같아야 메소드 오버라이딩이 성립한다.
- 오버라이딩을 하면, 참조변수의 형에 상관없이 오버라이딩 한 메소드가 기존의 메소드를 대신하게 된다.
- 부모클래스 a = new 자식클래스()로 선언되었고 자식클래스에 사용할 메소드가 오버라이딩이 되어 있다면 자식클래스의 메소드가 사용됨
- ex) 부모클래스 a = new 자식클래스() / 자식클래스 a = new 자식클래스() => 만약 호출하려고 하는 메소드가 오버라이딩 되어 있다면
메소드를 호출했을 때 부모클래스의 메소드를 호출할 수 없다.
- 하지만 클래스 내부에서 부르는 방법은 있다 super의 메소드를 호출하면 된다 ex) super.method() 
- 오버라이딩으로 super의 메소드를 부르면서 접근 범위를 넓혀 줄 수 있다.

인스턴스 변수와 클래스 변수의 오버라이딩 => X
- 상위클래스에 선언된 변수와 동일한 이름의 변수를 하위 클래스에서 선언하는 일은 가급적 피해야한다. => 코드에 혼란 야기
- 변수는 오버라이딩 되지 않는다
- 클래스 변수와 클래스 메소드 또한 오버라이딩의 대상이 아니다.
- 오버라이딩이 되지 않기 때문에 참조변수의 형에 따라서 접근한다.

instanceof 연산자 : 참조변수가 참조하는 인스턴스의 '클래스'나 '상속하는 클래스'를 묻는 연산자
- ex) if (ca instanceof Cake) => True of False
- 함수의 매개변수로 가장 최상위 클래스의 참조변수가 위치해있고 인자로 많은 하위클래스의 종류가 대입되면 instanceof를 사용해서
가려낼 수 있음 => 해당 클래스의 인스턴스가 내가 부여하는 클래스에게 상속받는지 확인할 수 있음
=> 연산자 instanceof는 명시적 형 변환의 가능성을 판단해주는 연산자이다.

----------------------------overloading VS overriding --------------------------------

오버로딩 : 메소드의 이름은 같은데 메소드의 매개변수 정보(수, 자료형)이 다른 메소드를 다중으로 정의 하는 것
- 생성자도 오버로딩 가능

오버라이딩 : 상위클래스에 정의된 메소드를 무효화시키다.
- 메소드 오버라이딩은 상위 클래스에 정의된 메소드를 하위 클래스에서 다시 정의하는 것을 뜻함.
- 메소드의 이름, 메소드의 반환형, 메소드의 매개변수 선언이 모두 같아야 오버라이딩 됨.
- 오버라이딩을 하면, 참조변수의 형에 상관없이 오버라이딩 한 메소드가 기존의 메소드를 대신하게 된다.

----------------------- 16 단원 : 클래스의 상속 : 상속의 목적 ------------------------

상속을 하는 이유 : 연관된 일련의 클래스들에 대해 공통적인 규약을 정의할 수 있다. 
- ex) 대학동창 or 직장동료  -> 클래스가 2개
       친구 <=상속= 대학동창 or 직장동료 -> 클래스는 3개지만 참조변수를 친구로하면 하나로 통일할 수 있음.
- 컴파일러의 참조변수형에 따른 접근이 유리한 이유는 여러가지로 나눠진 상속받는 클래스들을 한데 모아서 처리할 수 있는 장점이 있음 (+ 오버라이딩)

모든 클래스는 Object 클래스를 상속한다. 
-> 물론 다음과 같이 상속하는 클래스가 있는 경우에는 Object 클래스를 상속하지 않는다.
-> 하지만 상위클래스는 Object 클래스를 상속할 것이기 때문에 해당 클래스도 결국엔 Object 클래스를 상속한다. 
-> 모든 클래스는 Object 클래스를 간*직접적으로 상속한다. 왜?
-> 그러한 이유는 자바의 모든 인스턴스에 공통된 기준 및 규약을 적용하기 위함이다.

클래스를 정의하는데 있어서 해당 클래스를 다른 클래스가 상속하는 것을 원치 않는다면 final 키워드를 쓰면 된다.
-> String 클래스는 final을 사용하기 때문에 String 클래스를 상속할 수 없다.
-> 메소드에도 final 키워드를 사용하면 오버라이딩 할 수 없다.

@override 키워드 : override를 할 목적이 있는 메소드에 명시해놓으면 컴파일할 때 이 메소드가 정말로 오버라이드 되었는지 
에러를 발생시키면서 프로그래머에게 확인시킴 
=> 오버라이드가 안되면 에러 발생
=> 오버라이드를 하려고 메소드를 만들었는데 반환형이나 인자의 자료형을 다르게 주입해서 오버라이드가 안될 경우에는
새로운 메소드가 생성되는거지 오버라이드가 되는 것이 아닌 문제가 발생하지만 에러는 발생하지 않기 때문에 이후에 치명적인
결함이 될 수 있음

----------------------- 17 단원 : 인터페이스와 추상클래스 ---------------------------

인터페이스 : 기본 골격은 클래스와 동일 하지만 class 대신 interface라는 키워드가 붙는다
- 메소드는 정의 없이 선언과 세미콜론으로 마무리된다.
- 인터페이스를 대상으로는 인스턴스 생성이 불가하다. // new (X)
- 다만 다른 클래스에 의해 상속(구현)이 된다. 상속될땐 extends가 아닌 implements키워드를 사용한다 (상속이 아닌 구현)
- 구현할 인터페이스를 명시할 때 키워드 implements를 사용한다.
- 한 인터페이스는 둘 이상의 클래스를 동시에 구현할 수 있다.
- 상속과 구현은 동시에 가능하다.
- ex) class Robot extends Machine implements Movable, Runnable { ... }
- 인터페이스의 형을 대상으로 참조변수의 선언이 가능하다.
- 인터페이스의 추상 메소드와 이를 구현하는 메소드 사이에 오버라이딩 관계가 성립한다.

인터페이스의 본질적 의미 : 사전적의미 => 연결점, 접점
- 두 업체가 있으면 한 업체에서는 정보를 전달하고 한업체에서는 그 정보를 통한 가공을 해야하는데 그사이에서 접점 역할을 함
- 정보를 전달하는 업체에서 인터페이스를 만들고 정보를 조달 받은 업체에서 그 인터페이스를 implements 하여 클래스를 만들고
그 클래스에서 원하는 작업을 수행함.

인터페이스의 선언되는 메소드와 변수
- 모든 메소드는 public이 선언된 것으로 간주함. public을 붙일 필요가 없음..
- 모든 변수는 public, static, final이 선언된 것으로 간주하며, 선언과 동시에 값으로 초기화해야함 (final) 
- 접근 가능한 상수 -> 모든 변수 대문자로 작성 (상수)

인터페이스를  implements 하는 클래스는 인터페이스에 존재하는 모든 추상 메소드 구현해야한다.

인터페이스 간 상속
- 만약에 위의 내용처럼 인터페이스를 implements 하는 클래스는 인터페이스의 모든 추상 메소드를 구현해야한다.
- 하지만 인터페이스에서 새로운 기능이 만들어져서 새로운 추상메소드를 만들어야한다면? 
- 이 인터페이스를 implements 하는 클래스들 모두 수정해야하며, 클래스 내에 굳이 필요없는 메소드를 구현해놓아야한다.
- 이러한 비효율을 없애기 위해서 인터페이스 간에도 상속을 지원하고 있다.
- 두 인터페이스 사이의 상속도 extends로 명시한다.
- 두 클래스 사이의 상속은 extends로 명시한다.
- 인터페이스와 클래스 사이의 구현만 implements로 명시한다.

앞에서 말한 문제점을 해결하는 방법은 상속말고도 디폴트 메소드를 사용하는 방법이있다.
- 인터페이스 상속으로 해결하게 되면, 인터페이스의 수는 두배로 늘어나 개발에 불편을 일으킬 수 있다.
- 메소드 앞에 default 키워드를 입력하고 이 디폴트 메소드는 선언이 아니라 정의이기 때문에 스코프를 명시해야한다.
- 자체로 완전한 메소드다 => 추상메소드가 아니다.
- 따라서 이를 구현하는 클래스가 오버라이딩 하지 않아도 된다. => 위의 문제 해결
- 이미 정의해놓은 인터페이스를 구현하는 클래스들을 고치지 않아도 된다.
- 디폴트 메소드는 처음에 작성하는 메소드가 아니고 추상메소드의 확장시 사용해야할 문법이다.

인터페이스의 static 메소드(클래스 메소드)
- 클래스에 정의하는 static 메소드와 유사하다.
- 인터페이스에도 static 메소드를 정의할 수 있다.
- 그리고 인터페이스의 static 메소드 호출 방법은 클래스의 static 메소드 호출 방법과 같다.
- 따라서 오버라이딩에 대상이 아니다.

인터페이스 대상의 instanceof 연산
- 인터페이스를 직접(implement A) 혹은 간접(extends A)적으로 구현한 클래스의 인스턴스인 경우 true

인터페이스의 또 다른 사용 용도 : Marker Interface
- 인터페이스는 클래스에 특별한 표식을 다는 용도로도 사용된다. => 마커 인터페이스
- 표식처럼 메소드와 같은걸 선언해놓지 않고 소속을 구별하는 것에서 사용한다 if, instanceof에 구별하여 사용하기 위해

추상클래스 : Abstract Class => ??
- class 앞에 abstract 를 명시해줘야한다.
- 성격이 인터페이스와 유사하다.
- 추상클래스를 대상으로 인스턴스 생성도 불가능하다.
- 다른 클래스에 의해서 추상메소드가 구현이 되어야 한다.
- 위의 내용은 인터페이스와 비슷하지만 키워드는 implement가 아닌 extends를 사용한다.
- 정리하자면 여느 클래스와 마찬가지로 인스턴스 변수와 인스턴스 메소드를 갖지만, 이를 상속하는 하위클래스에 의해서 구현되어야
할 메소드가 하나 이상 있는 경우 이를 '추상클래스'라고 한다.

----------------------- 18 단원 : 예외처리 ------------------------------------------------------

예외란 단순한 문법 오류가 아닌 실행 중간에 발생하는 정상적이지 않은 상황을 뜻함
가상머신은 예외의 원인은 알지만 프로그래머가 원하는 예외의 처리방식까지는 알지 못한다.

예외처리방법: try ~ catch 
try {  ... 관찰 영역 ... }
catch (Exception name) { ... 처리 영역 ... }
- try 영역에서 발생한 예외 상황을 catch 영역에서 처리한다.
- catch 영역은 생김새가 메소드와 유사하며 실제로 메소드와 같이 동작한다.
- catch 영역으로 예외 인스턴스가 전달이 되면, 가상머신은 예외가 처리된 것으로 판단한다.
- 둘이상의 예외에 대한 처리는 catch문을 연달아서 작성해주면 된다.
- 그렇거나 아니면 파이프라인으로 연결해서 catch의 인자로 넣어주면 된다. ex) catch( ArithmeticException | InputMismatchException e) { ... }

예외 클래스의 최상위 클래스 Throwable
- 메소드 : getMessage() - 예외의 원인을 담고 있는 문자열을 반환 / printStackTrace() : 예외가 발생한 위치와 호출된 메소드의 정보를 출력
- 특정 메소드에서 예외처리를 하지 않으면 이전에 불리기 전에 쌓였던 스택의 메소드에 예외처리를 넘기고 마지막엔 main에게 떠넘겨지고 그 후 가상머신이 예외를 처리한다.
- 가상머신도 printStackTrace()의 메소드를 호출해서 예외처리를 한다.

ArithmeticException : 예외적인 산술조건
InputMismatchException : 잘못된 입력에 대한 예외
ArrayIndexOutOfBoundsException : 배열의 잘못된 인덱스 접근 예외
ClassCastException : 허용할 수 없는 형 변환을 강제로 진행했을 때의 예외
NullPointerException : null이 저장된 참조변수를 대상으로 메소드를 호출할때 발생하는 예외

Throwable - { Error / Exception / RuntimeException } 

- Error 클래스를 상속하는 예외 클래스
=> VirtualMachineError / IOErorr : 예외 처리의 대상이 아니다 (하드웨어의 에러)

- RuntimeExcepiton 클래스를 상속하는 예외 클래스
=> ArithmeticException / ClassCastException / IndexOutOfBoundsException / NegativeArraySizeException(배열길이 음수지정) 
=> NullPointerException /ArrayStoreException (배열에 적합하지 않는 인스턴스 저장) : 이와 같은 것들도 프로그래머가 일일이 예외처리를 하지 않음 / 수정해야할 상황

- (RuntimeExcepiton 클래스를 직/간접으로 상속하지 않고) Exception 클래스만 상속하는 예외 클래스 
=> 종류가 매우 많지만 이번엔 java.io.IOException 만 설명하기로 한다.
=> Exception 클래스만 상속하는 예외 클래스에서는 무조건 try..catch로 예외처리를 해줘야한다.
=> 따라서 선택이 아니다.. 그렇기 때문에 자바에서는 예외처리가 필수라고 한다.
=> 메소드에서는 메소드 정의에 throw와 해당 예외를 입력해서 해당 메소드를 호출했던 함수에 예외처리를 위임할 수 있다.
=> java.io.IOException : I/O 오류가 발생하는 경우에 throw되는 예외

프로그래머가 정의하는 예외 : 
- 지금까지 알아본 예외 클래스는 자바에서 정의한 클래스
- 프로그래머가 직접 예외 클래스를 정의하고 이를 기반으로 특정 상황에서 예외가 발생하도록 할 수도 있다.
- 이러한 클래스들의 핵심은 Exception을 상속하는데 있다.
- Exception을 상속하는 사용자 정의 예외클래스는 생성자로 super 생성자를 호출하여 문자열을 보내면 상위 클래스의 getmessage() 메소드의 반환 값이 된다.
- 사용자 정의 예외 클래스 또한 메소드를 호출한 메소드가 예외를 처리하도록 위임(throws) 할 수 있으며
- 예외 발생하는 부분에 throw new 예외클래스()를 입력해서 의도적으로 예외처리를 할 수 있다. (에러가 아니지만 사용자 입장에서 에러로 취급할 수 있다.)

잘못된 catch 구성 
- catch문을 연달아 이었을때 첫번째 catch문의 인자가 두번째 catch문의 인자의 상위클래스라면 두번째 catch문은 실행되지 않는다.
- 따라서 모든 catch문이 실행되도록 의도하고 싶다면 반대로 나열해주면 된다.

finally 구문
- try...catch문 이후에 finally 구문이 구현된다.
- finally 구문은 코드의 실행이 try 안으로 진입하면 무조건 실행된다. 
- try에서 예외가 발생하던 안하던, catch 문이 실행되건 안되건 무조건 실행된다.
- 파일을 닫을 때나 사후 처리를 해야할 때 사용된다.

try-with-resources 구문 
- try 구문이 메소드처럼 보임. 하지만 메소드와 유사하게 동작하지도 않음
- try 뒤의 소괄호 안은 종료와 과정을 필요로 하는 리소스를 생성할 수 있다.
- 리소스들을 소괄호 안에 정의 해놓으면 java.lang.AutoCloseable 인터페이스에서 자동을 종료하게한다.
- 세미콜론으로 구분하여 여러개의 리소스를 정의할 수 있음.
- 코드가 매우 간결해진다.

예외처리는 성능의 저하로 이어진다.
- try 구문안에 위치한 코드는 try 구문 밖에 위치한 코드에 비해 실행속도가 느리다.
- 따라서 과도한 예외처리는 지양한다.

----------------------- 19 단원 : 자바의 메모리 모델과 Object 클래스 -----------------------

1) 자바 가상머신의 메모리 모델

가상머신은 운영체제 위에서 동작한다는 사실 잊지 않으셨지요?
- 가상머신의 실행에 필요한 메모리는 어떻게 제공? 메인메모리(램)
- 운영체제가 메모리를 관리하고 응용프로그램에게 메모리를 할당해줌

자바 가상머신의 메모리 살림살이
- 가상머신은 운영체제로 부터 할당받은 메모리 공간을 효율적으로 사용하기 위해 메모리 공간을 3가지로 나눈다.
- 메소드 영역 : 메소드의 바이트코드, static 변수
- 스택 영역 : 지역변수, 매개변수
- 힙 영역 : 인스턴스

메소드 영역
- 자바 가상머신에 의해 실행이 가능한 코드를 가리켜 바이트 코드라한다.
- 인스턴스의 생성 및 클래스 변수의 접근을 위해서는 먼저 해당 클래스의 바이트 코드가 메모리공간에 로딩 되어야한다.
- 이때 로딩되는 공간이 메소드 영역이다.
- 특정 클래스의 정보가 메모리 공간에 올려질 때 채워지는 영역

스택 영역
- 지역변수와 매개변수가 저장되는 공간
- 중괄호로 구분되는 지역 내에서만 유효한 변수들이다.
- 중괄호 내에 할당된 이후에 해당 중괄호를 벗어나면 바로 소멸되는 특성의 데이터 저장을 위한 영역
- 메소드 호출 시 매개변수나 변수 스택에 할당 메소드가 끝이나면 스택에서 소멸

힙 영역
- 인스턴스의 소멸 시점과 소멸 방법이 지역변수와 다르다.
- 참조변수는 스택영역에 위치하고 인스턴스는 힙영역에 위치하며 둘이 참조하여 이어져있음.
- 인스턴스의 소멸시기를 결정하는 것은 가상머신의 역할이다.
- 가상머신의 메모리 관리 방식을 어느정도는 알고 있어야 메모리를 효율적으로 사용하는 좋은코드를 작성할 수 있다.
- 가상머신에 의한 가비지 컬렉션이 일어나는 메모리 공간이다.

자바 가상머신의 인스턴스 소멸시기
- 참조(참조변수와 인스턴스의 링크)가 끊기면 가상머신은 그러한 인스턴스를 소멸의 대상으로 취급한다.
- 그러한 이유는 더이상 인스턴스에 접근할 수 없기 때문이다.
- 이러한 소멸방식을 '가비지 컬랙션'이라고 한다. 

2) Object 클래스

인스턴스 소멸 시 해야 할 일이 있다면 : finalize 메소드
- Object 클래스에 정의되어 있으며 인스턴스가 가비지 컬랙션에 의해 소멸되기 전에 자동으로 호출된다.
- 인스턴스 소멸 시 반드시 실행해야 할 코드가 있다면 이 메소드의 오버라이딩을 고려하자
- 가비지 컬랙션은 빈번히 일어나지 않는다. 또 소멸할 인스턴스가 생겨도 가비지 컬렉션으로 바로 이어지지 않는다.
- System.gc() : 가비지 컬렉션의 수행을 요청 (명령이 아닌 요청)
- System.runFunalization() : 소멸이 보류된 인스턴스의 finalize 메소드 호출을 요청(명령이 아닌 요청)
- 가비지 컬렉션을 강제로 진행하지 말자. 가상머신이 알아서 효율적으로 수행한다.
- protected void finalize() throws Throwable { }

인스턴스의 비교 : equals 메소드
- 두 인스턴스의 내용 비교를 원한다면 Object 클래스의 equals 메소드를 오버라이딩하자.
- == 는 인스턴스까지 본다면 참조변수의 참조값을 비교하기 때문에 내용은 같더라도 참조값이 달라서 false로 나옴

인스턴스 복사(복제) : clone 메소드
- 이 메소드가 호출되면, 호출된 메소드가 속한 인스턴스의 복사본이 생성되고, 이렇게 만들어진 복사본의 참조 값이 반환된다.
- interface Cloneable => 이 인터페이스를 구현한 클래스의 인스턴스만 clone 메소드 호출 가능
- 위의 인스턴스를 구현하지 않으면 CloneNotSupportedException 예외가 발생한다. 
- Cloneable 인터페이스의 구현은 어떤 의미가 있나? =>이 클래스의 인스턴스는 복제해도 된다. 즉 clone 메소드 호출이 가능하다. => 마커 인터페이스
- 인스턴스의 복사는 클래스에 따라 허용해서는 안되는 작업이 될 수 있다. 따라서 복사 허용 여부는 정의하는 과정에서 고민하고 결정해야한다. => Cloneable 구현!!
- clone() 메소드를 오버라이딩 해야하는 이유는 접근범위를 넓혀 줄수 있고(protected -> public) throws를 사용해서 예외처리를 해줄 수 있다.
- 기본적으로 clone 메소드는 깊은 복사지만 클래스 내부에서는 얕은 복사가 이뤄질 수 있다. ( 클래스 내부에서 인스턴스를 생성한 경우 ) => 따라서 clone 메소드를 오버라이딩 해줘야한다.

인스턴스 변수가 String인 경우의 깊은 복사
- String 클래스가 Cloneable 인터페이스를 구현하지 않은 이유는 무엇일까
- String은 문자열의 수정이 불가능하느므로, 깊은 복사의 대상에서 제외해도 된다.
- 따라서 서로 다른 인스턴스가 하나의 String 인스턴스를 공유해도 문제가 되지 않는다.

clone 메소드의 반환형 수정 : Covariant Return Type
- clone 메소드의 반환형은 Object이다. 따라서 clone 메소드를 호출하면서 동시에 형 변환도 진행해야한다.
- 그런데 자바 5 이후 부터는 오버라이딩 과정에서 반환형의 수정을 허용한다.
- 하지만 무엇이든 그런 것이 아니고, 자신이 속한 클래스형으로 반환이 가능하다.
- 따라서 clone 메소드를 사용할때 Object가 아닌 자신의 클래스형으로 반환이 가능하다.

----------------------- 20 단원 : 자바의 기본 클래스 ------------------------------------------

1) 래퍼  클래스 (Wrapper 클래스)

기본 자료형의 값을 감싸는 래퍼 클래스
- 감싸는 클래스, 래퍼 클래스는 기본 자료형의 값을 감싸는 클래스이다.
- 래퍼클래스도 toString 메소드를 오버라이딩 하고 있다. (Object 클래스)
- 기본 자료형에 대한 래퍼클래스 
- Boolean	public Boolean(boolean value)
- Character	public Character(char value)
- Byte		public Byte(byte value)
- Short		public Short(short value)
- Integer		public Integer(int value)
- Long		public Long(long value)
- Float		public Float(float value) / public Float(double value)
- Double		public Double(double value)

래퍼클래스의 두가지 기능
- 첫번째는 값을 인스턴스로 감싸는 것(박싱), 두번째는 인스턴스에서 값을 꺼내는 것(언박싱).
- ex) Integer iObj = new Integer(10); [박싱] / int num1 = iObj.intValue(); [언박싱]
- Boolean	public boolean booleanValue()
- Character	public char charValue()
- Integer		public int intValue()
- Long		public long longValue()
- Double		public double doubleValue()

오토 박싱(Auto Boxing) & 오토언박싱(Auto Unboxing)
- 자바 5부터 박싱과 언박싱을 자동으로 처리하기 시작함
ex) Integer iObj = 10; [박싱] / int num1 = iObj; [언박싱]
     iObj++; => new Integer(num.intValue() + 1);

Number 클래스와 래퍼 클래스의 static 메소드
- 모든 래퍼 클래스는 java.lang.Number 클래스를 상속한다.
- 포함하는 추상 메소드 int intvalue() / long longValue() / double doubleValue()
- 따라서 예를 들면 Integer 인스턴스도 doubleValue() 메소드를 사용해서 언박싱 할 수 있다.
- 래퍼 클래스의 static 메소드 : valueOf(a) / max(a, b) / min(a, b) / sum(a, b) / toBinaryString(a) / toOctalString(a) / toHexString(a)
- 자바 문서에는 더있으니.. 살펴보는 것을 권장..

2) BigInteger 클래스와 BigDecimal 클래스

매우 큰 정수의 표현을 위한 java.math.BigInteger 클래스
- long으로도 표현 불가능한 수를 표현해야 할때 BigInteger 클래스를 사용
- Long.MAX_VALUE (long 최댓값) / Long.MIN_VALUE (long 최솟값)
- BigInteger 메소드 : add(BI) : 덧셈 / subtract(BI) : 뺄셈 / multiply(BI) : 곱셈 / divide(BI) : 나눗셈 몫 / remainder(BI) : 나눗셈 나머지
- longValueExact() => BI를 long으로 변환 / intValueExact() => BI를 int로 변환 (변환할 수 없는데 호출하면 ArithmeticException 예외가 발생)

오차 없는 실수의 표현을 위한 java.math.BigDecimal 클래스
- 오차 없는 실수의 표현을 위해 제공되는 클래스
- BigDecimal 메소드 : add(BD) : 덧셈 / subtract(BD) : 뺄셈 / multiply(BD) : 곱셈 / divide(BD) : 나눗셈
- 오차가 생기지 않게 박싱할 때 문자열로 숫자를 입력한다.

3) Math 클래스와 난수 생성, 그리고 문자열 토큰(Token)의 구분

수학 관련 다양한 연산의 제공을 위한 Math 클래스
- 수학관련 메소드는 다합치면 그수가 70개를 넘는다. => 자바 문서 참고
- Math.PI : 원주율 / Math.sqrt(a) : a의 제곱근 / Math.toDegrees(a) : a는 몇도인지 / Math.toRadian(a) : degree를 라디안으로 변환
- Math.sin(a) / Math.cos(a) / Math.tan(a) = > 사인, 코사인, 탄젠트 / Math.log(a) : a 의 로그 값 / Math.pow(a, b) : a^b 

난수(Random Number )의 생성
- 난수는 예측 불가능 한 수를 의미한다. // java.util.Random => Random rand = new Random();
- nextBoolean() : boolean형 난수 반환 / nextInt() : int형 난수 반환 / nextLong : long형 난수 반환
- nextInt(int bound) : 0 ~ bound미만 범위의 int형 난수 반환 / nextFloat() : 0.0 ~ 1.0미만 float형 난수 반환 / nextDouble() : 0.0 ~ 1.0미만의 double형 난수 반환

씨드(Seed) 기반의 난수 생성
- 난수 생성에서도 숨겨진 패턴이 존재할 수 밖에 없다. => Pseudo-random number(가짜 난수)
- Random 생성자에 전달된 숫자는 난수 생성과정에서 씨앗(씨드 값)으로 사용된다. => 따라서 씨드 값이 같으면 몇번을 돌려도 다 같은 값이 나온다.
- 난수를 만들때 생성자에서 자동으로 System.currentTimeMills() 인자로 넣는다. 이는 협정시인 컴퓨터의 현재시간을 밀리초로 계산한 것인데
- 이것을 자동으로 삽입하므로써 씨드 값이 계속 변경되어 난수가 발생한다.
- setSeed(seed) 메소드를 사용해서 씨드값을 변경해줄 수도 있다.

문자열 토큰(Token) 구분
- java.util.StringTokenizer;
- 특정 기준을 가지고 문자열을 작게 나누어야 할 때 => StringTokenizer 클래스
- ex) StringTokenizer st = new StringTokenizer("PM:08:45", ":"); => 문자열과 구분자 인자로 부여
- ex) StringTokenizer st = new StringTokenizer("12 + 36 - 8 / 2 = 44", "+-/= ") => 숫자만 추출, 구분자로 넣은 것들을 전부 다 제외시킴
- 3번째 인자에 true를 주면 구분자도 토큰으로 취급하도록 함
- hasMoreTokens() :  반환할 토큰이 남았는가? True or False
- nextToken() : 다음 토큰 반환
- 다음 토큰이 없는데 nextToken()을 반환하면 예외가 발생 => hasMoreTokens()와 함께 사용해야한다.

4) Arrays 클래스
- java.util.Arrays

배열의 복사
- Arrays.copyOf(기존 배열, 길이) : 기존배열을 처음부터 길이만큼 복사해서 새로운 배열을 리턴하는 메소드
- Arrays.copyOfRange(기존배열, 시작, 끝) : 기존배열을 시작인덱스 부터 끝 전까지 복사하여 새로운 배열을 리턴하는 메소드
- System.arraycopy(기존 배열, 기존 시작, 복사받는 배열, 복사받는 배열 시작, 길이) : 기존 배열에 시작부터 길이만큼 복사해서 복사받는 배열의 시작에 복사함.
- 모든 기본자료형 배열을 대상으로 오버로딩 되어있는 것은 물론이고 특정 클래스의 인스턴스를 저장하는 배열까지도 오버로딩 되어있음.

배열의 비교
- Arrays.equals(배열, 배열) => 두 배열의 데이터 수, 순서, 내용이 같으면 true를 반환한다.  반환형 boolean (true / false) 
- Object형의 배열에 대해서도 오버로딩 되어있다. 하지만 이 equals 메소드는 참조변수 값이 동일한 지 확인하는 메소드기 때문에 false의 값이된다. 
- 그렇기 때문에 내용 비교를 위해서는 따로 equals 메소드를 목적에 맞게 오버라이딩 해주어야 한다.

배열의 정렬
- Arrays.sort(배열) : 매개변수로 전달된 배열을 오름차순으로 정렬
- Object 배열에 대해서도 오버로딩 되어 있다.
- Interface Comparable => int compareTo (Object o) 메소드 구현을 통해 인스턴스 순서 판단 기준을 결정한다. 
=> 인자로 전달된 o가 적다면 양의 정수 반환 / 크다면 음의 정수 반환 / o와 같다면 0을 반환
- Comparable 인터페이스는 자바에 제네릭이 도입되면서 Comparable<T> 인터페이스로 수정되었음. 하지만 호환성 유지를 위해 지금도 사용가능 함

배열의 탐색
- 모든 기본자료형에 대해서 오버로딩 되어 있음. 또 Object 배열에 대해서도 오버로딩 되어 있다.
- Arrays.binarySearch(배열, 키값) : 배열에서 key를 찾아서 있으면 key의 인덱스 값, 없으면 0보다 작은 수 반환
- 이진 탐색이라는 알고리즘을 기반으로 탐색을 진행한다. 그렇기 때문에 꼭 정렬한 다음에 진행해야한다.
- 메소드가 key와 동일한 인스턴스를 찾았다고 판단하는 기준은 Comparable 인터페이스의 compareTo 메소드가 그 기준이다.

----------------------- 21 단원 : 제네릭 1 ------------------------------------------------------

1) 제네릭의 이해
- 제네릭은 자바 컬렉션 프레임워크의 이해를 위한 필수 개념!
- 클래스 내부에서 사용할 데이터 타입을 외부에서 지정(인스턴스를 생성할 때 확정)하는 기법을 의미한다
- 제네릭이 갖는 의미는 일반화이다. 그 일반화의 대상은 자료형이다.
- 자료형에 의존적이지 않은 클래스를 정의할 수 있게 됨

제네릭 이전의 코드
- 중복 제거(Apple -> AppleBox / Orange -> OrangeBox) => (Apple/Orange -> Box) 
 ㄴ Box 클래스 내부의 참조변수의 형을 Apple, Orange -> Object로 바꿔서 취급
 ㄴ> 문제점 : 사용 시 형변환의 문제 / 모든 클래스를 다 포괄할 수 있는 Object로 바꿨기 때문에 원치않는 자료형이 인스턴스 내부로 스며들게 되어 예기치 못한 에러가 발생할 수 있음
                                                  ㄴ 이는 컴파일시 에러가 발생하지 않기 때문에 치명적일 수 있거나.. 원치 않는 값을 가질 수 있음..

제네릭 기반의 클래스 정의하기
- 클래스 내부에 인스턴스 생성시 정의하고 싶은 자료형을 타입매개변수(T, 즉 대문자 1개)로 지정해놓고 클래스의 이름 옆에 '<>'를 작성한 뒤 그 안에 타입 매개변수를 적음 ex) class Box<T> {private T a; }
- 이제 T는 인스턴스 생성시 결정하면 된다. 이렇듯 인스턴스 생성시 T의 자료형을 결정하는 것이 제네릭
- <T>는 인스턴스 생성시 T의 자료형을 결정하겠다는 표식이다.

- 인스턴스 생성 : ex) Box<Apple> aBox = new Box<Apple>();
 => T를 Apple로 결정하여 인스턴스 생성
 => 따라서 Apple 또는 Apple을 상속하는 하위 클래스의 인스턴스 저장 가능 // 상속 때 배웠던 일반화를 말함 (매개변수 = 인자) ex) aBox.set(new AP) / Ap가 apple을 상속한다면 이게 가능하단 뜻
- 타입 매개변수 : Box<T> 에서 T
- 타입 인자 : Box<Apple>에서 Apple
- 매개변수화 타입(제네릭 타입) : Box<Apple>

제네릭 이후의 코드
- 필요시 형변환을 해야한다.(이전) => 형변환을 하지 않아도 된다. (이미 인스턴스 생성시 클래스 내부의 멤버의 형을 정의했기 때문에)
- 자료형과 관련된 프로그래머의 실수가 컴파일 과정에서 드러나지 않는다. => 드러난다. (Object와 다르게 인스턴스 생성시 형이 정의됐기에 애초에 형이 맞지 않는 자료형을 받지않는다.(컴파일 오류))

2) 제네릭의 기본 문법

- 둘 이상의 타입 매개변수에 대한 제네릭 클래스도 정의할 수 있다. ex) Class Dbox<L, R>
- 타입 매개변수 작성 규칙 : 한문자&대문자
- 보편적 사용 => ( E -> Element / K -> Key / N -> Number / T -> Type / V -> Value )
- '매개변수화 타입'을 구성할 땐 '기본자료형'은 '타입인자'로 쓸 수 없다. (참조 자료형만 가능) 대신 래퍼 클래스를 사용하면 된다 ex) int => Integer(어차피 오토인박싱&오토박싱이 자동 사용됨)
- 타입 인자의 생략<다이아몬드 기호> : 컴파일러는 프로그래머가 작성하는 제네릭 관련 문장에서 자료형의 이름을 추론하는 능력을 가지고 있다. 그래서 생략이 가능하다.
 ㄴ> Box<Apple> aBox = new Box<Apple>();     =>      Box<Apple> aBox = new Box<>(); (인스턴스 생성의 Apple 생략 )  // 다이아몬드 기호 또는 표시
- '매개변수화 타입'을 '타입 인자'로 전달할(사용 될) 수 있다. // ex) Box<String> => Box<Box<String>> => Box<Box<Box<String>>>  // 체이닝이 가능하다..
 ㄴ> 이걸 보면 다이아몬드 기호를 통한 타입 정보의 생략이 가능함이 다행임..  // ex) Box<Box<Box<String>>> zBox = new Box<Box<Box<String>>>() ( new Box<>()로 교체 가능 )

제네릭 클래스의 타입 인자 제한하기 (클래스 + 인터페이스 )
- extedns 로 제한이 되어 있지 않다면 <T extends Object>임 평소에 extends Object가 생략 되어 있다고 생각하면 됨.
- ex) Number 클래스를 상속하는 클래스의 인스턴스(Number과 Number의 하위 클래스) 만 담고 싶다면 => class Box<T extends Number> {...}
- extends로 타입 인자를 제한하면 제한하는 클래스의 메소드를 사용할 수 있다. => 제한하는 클래스가 상위클래스이기 때문에 하위클래스는 상위클래스의 메소드를 100% 사용가능하기 때문
- 하지만 제한이 되어 있지 않다면 다른 메소드를 사용할 순 없고 <T extends Object>이니깐 Object의 메소드는 사용이 가능하다.
- ex) class Box<T extends Number> {...}  => intvalue() 사용 가능... 그리고 모든 클래스는 Object의 하위 클래스이기 때문에 toString() 사용 가능
- ex) class Box<T> {...} => intvalue() 사용 불가능... 하지만 toString() 사용가능 (Object의 메소드)

- 인터페이스도 동일하다. 키워드도 똑같이 extends를 사용하고 똑같이 메소드도 제한되며 인터페이스를 구현하는 하위 클래스만 인스턴스를 만드는 것을 허용한다.
- 또 인터페이스와 클래스에 대해 동시에 제한을 할 수가 있다. ex) class Box<T extends Number & Eatable > { ... }

제네릭 메소드의 정의
- 클래스 전부가 아닌 일부 메소드에 대해서만 제네릭으로 정의하는 것도 가능하다. => 제네릭 메소드
- 인스턴스 메소드 뿐만 아니라 클래스 메소드 (static) 에 대해서도 정의가 가능하다. => static 선언의 유무에 상관없다.
- 메소드 정의 : ex) public static <T> Box<T> makeBox(T o) { ... } 
 ㄴ> static : 인스턴스 메소드 or 클래스 메소드 // <T> : 타입 매개변수 // Box<T> : 반환형 // makeBox : 메소드 이름 // (T o) : 매개변수 
- 제네릭 클래스는 인스턴스 생성시 자료형이 결정 // 제네릭 메소드는 '메소드 호출시'에 자료형 결정
- 메소드 호출 : ClassName.<String>makeBox("Sweet");
 ㄴ> ClassName: 클래스 이름 or 인스턴스 이름 // <String>: 타입 인자 // makeBox : 메소드이름 // (T o) : 인자
 ㄴ> 컴파일러는 인자를 보고 타입인자를 유추할 수 있다.  => 인자에 아무것도 없어도 알아서 유추함.. 신기하구먼.. 

- 제네릭 메소드의 제한된 타입 매개변수 선언
ㄴ 제네릭 메소드도 제네릭 클래스 처럼 호출 시에 전달되는 타입 인자를 제한할 수 있다.
ㄴ 키위드는 extends로 동일하며 extends로 제한된 상위클래스의 메소드를 사용할 수 있다. (제한되지 않았다면 Object)

----------------------- 22 단원 : 제네릭 2 ------------------------------------------------------

1) 제네릭의 심화 문법

제네릭 클래스와 상속 : 제네릭 타입도 다른 타입과 마찬가지로 부모 클래스가 될 수 있음.
- 자식 제네릭 타입은 추가적으로 타입 파라미터를 가질 수 있다. 
- ex) public class ChildProduct<T, M, C> extends Product<T,M> { ... }
- 일반 클래스는 제네릭 클래스를 상속할 수 없다.
- 제네릭 클래스의 상속 관계가 성립하면 하위 클래스 인스턴스를 부모 클래스 참조변수로 참조할 수 있다. (일반화)
- ex) SteelBox<Integer> 제네릭 타입은 Box<Integer> 제네릭 타입을 상속한다.
- 하지만 Box<Number> box = new Box<Integer>(); => Number을 Integer가 상속하지만 Box<Number>와 Box<Integer>는 상속 관계를 형성하지 않는다. (컴파일 X)

타겟 타입
- 아까 21 단원에서 인자에 아무것도 없어도 타입 매개변수를 알 수 있다는 것에 신기하다고 했었다.
- 이 이유는 자바 7부터 컴파일러가 왼쪽에 참조변수로 선언된 타입 매개변수의 형을 보고 판단할 수 있게 되었다.
- 지금 설명한 상황에서 T의 유추에 사용된 정보를 가리켜 타겟 타입이라한다.
-  ex) public staitc <T> Box<T> makeBox() { ... }  	// 함수 정의 ( => 함수 매개변수의 값이 없음)
-       Box<Integer> iBox = EmptyBoxFactory.makeBox();  // 함수 사용시 인자 없어 타입 매개변수의 형을 알 수 없지만 참조변수의 <Integer>을 보고 컴파일러는 자료형을 유추할 수 있음.

와일드카드
- 제네릭 클래스 간의 상속은 가능하지만 ex) List<Integer> <- ArrayList<Integer>
- 제네릭 클래스의 타입 매개변수 간의 상속은 불가능하다 ex) List<Number> <- List<Integer>
- 하지만 그것을 가능하게 해주는 것이 <?> 와일드 카드이다. 
- 와일드 카드도 상한, 하한의 제한을 둘 수 있다. extends를 사용하면 자신을 포함한 하위 클래스 // super를 사용하면 자신을 포함한 상위클래스
- public static void peekBox(Box<? extends Number> box) { ... }  // "Box<T>의 T를 Number 또는 Number 하위 클래스로 제한하기 위한 것   // 상한 제한된 와일드 카드의 의미 ?!?!
- public static void peekBox(Box<? super Integer> box) { ... }  // "Box<T>의 T를 Integer 또는 Number 상위 클래스로 제한하기 위한 것   // 하한 제한된 와일드 카드의 의미 ?!?!

와일드카드의 상한, 하한 제한 ( 열혈 java 프로그래밍의 예제로 예시.. )  

※ 참조 클래스(자료형)의 관계 : Plastic <- Toy <- Car or Robot

- 원리 : 상위 클래스 참조변수에 하위 인스턴스를 대입할 수 있지만 하위 클래스 참조변수에 상위 인스턴스를 대입할 수 없는 원리를 이용한 것.

- 언제 와일드카드에 제한을 걸어야 하는가? : 상한 제한의 목적
ㄴ> public static void outBox(Box<? extends Toy> box) {
     	Toy t = box.get();       // 꺼내는 것 OK
	System.out.println(t);
	box.set(new Toy());     // 넣는 것 Error!  => 미시적으로보면 set의 매개변수 (T o) 인자는 new Toy() 
			    // 따라서 T o = new Toy() => but! extends는 Toy나 Toy의 하위 클래스만 접근할 수 있게 하기 때문에
			    // 현재 T는 Toy, Car, Robot 세가지의 경우가 있음
			    // Toy, Car, Robot 참조변수 = new Toy() (인스턴스) => [하위 = 상위] => (X 불가능) => 따라서 컴파일 시 에러 발생 
			    // 정확하게는 참조변수에 참조변수보다 하위 클래스이거나 참조변수와 같은 형의 인스턴스 대입을 보장할 수 없어서 에러가 발생함
      }

- 언제 와일드카드에 제한을 걸어야 하는가? : 하한 제한의 목적
ㄴ> public static void inBox(Box<? super Toy> box) {
	box.set(new Toy());     // 넣는 것 OK!
     	Toy t = box.get();       // 꺼내는 것 Error!  => 미시적으로보면 get은 T를 반환 
			    // 따라서 Toy t = T 형 인스턴스 => but! super은 Toy나 Toy의 상위 클래스만 접근할 수 있게 하기 때문에
			    // 현재 T 형 인스턴스는 Toy, Plastic 두가지의 경우가 있음
			    // Toy 참조변수 = Toy, Plastic 형 인스턴스 => [하위 = 상위] => (X 불가능) => 따라서 컴파일 시 에러 발생 
			    // 정확하게는 참조변수에 참조변수보다 하위 클래스이거나 참조변수와 같은 형의 인스턴스 대입을 보장할 수 없어서 에러가 발생함
      }
 ㄴ> Toy t 에서 참조변수 형을 Toy가 아닌 Object로 선언한다면? => 위의 get() 메소드의 반환형을 결정할 수 없기 때문에 반환형은 Object로 결정이 된다. 하지만 자바는 Object형으로 형변환이 불필요하도록
문법을 개선시켜왔고 (그것이 제네릭) Object를 남용시 컴파일러를 통한 오류 발생 가능성을 낮추는 행위이기 때문에 Object 사용을 지양하는 것은 당연한 일이다. => 사용하지 말자!

- 언제 와일드카드에 제한을 걸어야 하는가? : 정리하기
 - 매개변수 선언 : Box<? extends Toy> box 
 ㄴ> box가 참조하는 인스턴스(전달) 대상으로 꺼내는 작업만 허용하겠다는 의미 => get()
 - 매개변수 선언 : Box<? super Toy> box
 ㄴ> box가 참조하는 인스턴스(변경) 대상으로 넣는 작업만 허용하겠다는 의미 => set() 
 - public static void moveBox(Box<? super Toy> to, Box<? extends Toy> from) {
	to.set(from.get()); => ok     // Plastic, Toy 참조변수 = Toy, Robot, Car 인스턴스 [상위 = 하위] => ( O )
	from.set(to.get()); => Error  // Toy, Robot, Car 참조변수 = Plastic, Toy 인스턴스 [하위 = 상위] => ( X )
   }

제한된 와일드카드 선언을 갖는 제네릭 메소드 // 와일드 카드(제한) + 제네릭 메소드(범용성, 중복제거)
- 앞선 내용을 Toy가 아니라 Robot이라는 클래스 관점으로 상한 하한 제한을 두고 싶다면? 메소드를 복사해서 Toy를 Robot으로 바꾸면 된다.
- 하지만 이것은 오버로딩이 안된다. 그 이유는 자바는 제네릭 등장 이전에 정의된 클래스들과의 상호 호환성 유지를 위해 컴파일 시 제네릭과 와일드카드 관련 정보를 지우는 과정을 거친다. 
ㄴ> 이러한 행위를 Type Erasure 이라고 한다.
ㄴ> Box<? extends Toy> box => Box box
ㄴ> Box<? extends Robot> box => Box box
- 따라서 두 메소드의 매개변수는 조금 다르지만 컴파일러는 같은 메소드로 인식한다. (이름 충돌)
- 그렇다면 Box<Toy> 인스턴스와 Box<Robot> 인스턴스를 동시에 허용할 수 있도록 inBox와 outBox를 정의하려면 어떻게 해야할까? 답은 제네릭 메소드이다. // Toy와 Robot 부분을 T로 바꾸면 된다.

제네릭 인터페이스의 정의와 구현
- 인터페이스 역시 클래스와 마찬가지로 제네릭으로 정의할 수 있다. ‌ex) interface Getable<T> { ... }  // class Box<T> implements Getable<T> { ... }
- 위와 같다면 Getable<T>형 참조변수로 Box<T>의 인스턴스를 참조할 수 있다. 단 T는 T여야한다.
- 제네릭 인터페이스를 구현할 때는 T를 결정한 상태로 구현할 수도 있다. ex) class Box<T> implements Getable<String> { ... } 
- 단 T를 모두 결정한 상태로 바꿔야한다. ex) Override ... public String get() { ... }
- 이러면 Getable 참조변수는 다음과 같이 인스턴스를 T의 자료형에 상관없이 참조할 수 있다. ex) Box<Toy> box = new Box<>(); Getable<String> gt = box;

----------------------- 23 단원 : 컬렉션 프레임워크 1 ----------------------------------------

1) 컬렉션 프레임워크의 이해
- 컬렉션 프레임워크 :  Iterator<E> <- Collection<E>
ㄴ 자료구조와 알고리즘을 제네릭 기반의 클래스와 메소드로 미리 구현해 놓은 결과물이다.
ㄴ 컬렉션 프레임워크는 프로그래머들이 쓰기에 편리하도록 잘 정의된 클래스의 모임이라고 하며 그렇다면 라이브러리가 되어야하는데 
ㄴ 그렇지 않은 이유는 컬렉션 관련된 클래스의 정의에 적용되는 설계 원칙 또는 구조가 존재하기 때문이다.
- 자료구조 : 데이터 저장 관련 학문으로 데이터의 탐색, 삭제 등 다양한 측면을 고려한 데이터의 효율적인 저장 방법을 연구하는 학문
- 알고리즘 : 저장된 데이터의 일부 또는 전체를 대상으로 하는 각종 가공 및 처리의 방법을 연구하는학문
- 컬렉션 프레임워크는 컬랙션 클래스들이 구현하는 인터페이스들의 상속관계가 있다. 그리고 그것들은 모두 제네릭으로 정의되어 있다.

- 대다수의 컬렉션 클래스들은 다른 컬렉션 인스턴스를 인자로 전달받는 "생성자"를 가지고 있어서 다른 컬렉션 인스턴스에 저장된 데이터를 "복사"해서 새로운 컬렉션 인스턴스를 생성할 수 있다.
 ㄴ ex) public ArrayList(Collection<? extends E> c) | public LinkedList(Collection<? extends E> c) | public HashSet(Collection<? extends E> c)
 ㄴ 인자의 <? extedns E> 는 컬렉션 클래스의 인스턴스인 인자의 값을 참조를 할 순 있지만 수정*변경을 못하도록 막기 위한 장치
- 컬렉션 인스턴스도 기본 자료형의 값은 저장하지 못한다. 그러나 래퍼클래스의 도움(오토박싱,언박싱)으로 이들 값의 저장 및 참조가 가능하다.
- System.out.println(Collection<E> c) => 출력에 컬렉션 클래스를 삽입하면 내용물이 집합적으로 보이게 출력된다.

- Iterator<E> 
 ㄴ Collection<E> 인터페이스는 Iterable<T>를 상속하기 때문에 사용가능하다. { List<E> / Set<E> / Queue<E> 인터페이스 하위 클래스 모두 사용가능 }
 ㄴ 따라서 Collection 하위 인터페이스나 클래스는 모두 Iterator<E>의 메소드를 구현하기 때문에 사용할 수 있다. ex) Iteraor<T> iterator() 이 ArrayList나 LinkedList에 구현되어 있음
 ㄴ 사용법 : E next() : 다음 인스턴스의 참조 값을 반환 | boolean hasNext() next메소드 호출 시 참조 값 반환 가능 여부 확인 | void remove() : next 메소드 호출을 통해 반환했던 인스턴스 삭제
  ex) 
  => Iterator<String> itr = list.iterator();
       while(itr.hasNext()) {
	str = itr.next(); 
       }
  => for(Iterator<String> itr = list.iterator(); itr.hasNext(); ) {
       	str = itr.next();
	if(str.equals("Box"))
	    itr.remove();
       }
 ㄴ 일반 for문이나 for-each 보다 성능이 좋은 이유는 완전 탐색 도중에 데이터를 삭제할 수 있다는 점이다.
 ㄴ 하지만 처음부터 끝까지 살펴보는 것이기 때문에 전 위치로 돌아가고 싶다면 다시 처음부터 반복해야하는 단점이 있다.

2) List<E> 인터페이스를 구현하는 컬렉션 클래스들 : <- ArrayList<E> / LinkedList<E> / Stack<E> (X) / Vector<E> (X)
- 클래스 불러오기 :  import java.util.List ( LinkedList / ArrayList / Iterator / ListIterator )
- List<E> 인터페이스를 구현하는 컬렉션 클래스의 공통적 특징 
 ㄴ> 인스턴스의 저장 순서를 유지한다.
 ㄴ> 동일한 인스턴스의 중복 저장을 허용한다.

- ArrayList<E> vs LinkedList<E>
ㄴ 두 클래스의 사용법
 => add(<E>형 값) : 데이터 저장 | get(인덱스) : 인덱스의 값 참조 | remove(인덱스) : 인덱스의 값 삭제 | size() : 데이터의 개수 반환
 => 두 클래스의 사용법은 동일하다 하지만 구조가 배열인지 리스트인지의 차이가 있다.
 => ArrayList인 경우 배열 길이가 중요하기 때문에 처음에 생성자를 통해서 ArrayList의 길이를 정할 수 있다. ex) new ArrayList<String>(20) 
 => LinkedList는 duque를 구현하는 클래스이기도 하기 때문에 양방향 반복자를 지원한다. 
  ㄴ public ListIterator<E> listIterator() // ListIterator<E>는 Iterator<E>을 상속한다.
  ㄴ Iterator<E>에 추가적인 메소드 : E previous() : next()의 반대 방향 | boolean hasPrevious() : hasNext() 메소드의 반대방향
  ㄴ next 호출 후에 add 호출하면, 앞서 반환된 인스턴스 뒤에 새 인스턴스 삽입 (오른쪽)
  ㄴ previous 호출 후에 add 호출하면, 앞서 반환된 인스턴스 앞에 새 인스턴스 삽입 (왼쪽)

ㄴ ArrayList<E> : 배열 기반 자료구조, 배열을 이용하여 인스턴스 저장
 => ArrayList 의 단점
   - 저장 공간을 늘리는 과정에서 시간이 비교적 많이 소요된다
   - 배열 중간을 비워 두지 않기 때문에 인스턴스 삭제과정에서 많은 연산이 필요할 수 있다.
 => ArrayList 의 장점  
   - 저장된 인스턴스의 참조가 빠르다 (인덱스 접근)

ㄴ LinkedList<E> : 리스트 기반 자료구조, 리스트를 구성하여 인스턴스 저장
 => LinkedList 의 단점
   - 저장된 인스턴스의 참조과정이 배열에 비해 복잡하다. 따라서 느릴 수 있다. (처음부터 순차적 접근)
 => LinkedList 의 장점
   - 저장 공간을 늘리는 과정이 간단 (새로 붙이고)
   - 저장된 인스턴스의 삭제 과정이 단순하다. (끊고 붙이고)
 
- 순차적 접근 방법 : for-each문을 사용해서 List 완탐이 가능하다. 
 ㄴ for-each도 Iteable<T>를 Collection<E>가 상속하기 때문에 사용할 수 있다. 따라서 하위 인터페이스인 LIst<E> 또한 사용이 가능하다.
 ㄴ for-each 문도 결과적으로는 컴파일러를 통해서 Iterator 문으로 자동 변경된다.

- 배열 vs 컬렉션 인스턴스
 ㄴ ArrayList<E>가 더 좋다. => 이유, 첫번째, 인스턴스의 저장과 삭제가 편하다. 두번째, 반복자를 쓸 수 있다.
 ㄴ 하지만 선언과 동시에 초기화를 할 수 없는 점이 조금 번거롭다.
 ㄴ 하지만 그것은 Arrays 클래스의 Arrays.asList()를 사용하면 되기 때문에 문제가 되지 않는다. ex)  List<String> list = Arrays.asList("Toy", "Robot", "Box");
 ㄴ 그러나 위처럼 생긴 list는 새로운 인스턴스의 추가나 삭제가 불가능하다. => 그런 경우는 ArrayList의 생성자를 통해서 인스턴스를 생성해야한다. 
 ㄴ public ArrayList((Collection <? extends E> c)
   => Collection<E>를 구현한 컬렉션 인스턴스를 인자로 전달받는다.
   => 그리고 E는 인스턴스 생성 과정에서 결정되므로 무엇이든 될 수 있다.
   => 덧붙여서 매개변수 c로 전달된 컬렉션 인스턴스에서는 참조만(꺼내기만) 가능하다. => 인자로 들어온 컬랙션 클래스의 기존의 값을 해치지 않기 위해
 ㄴ ex)  List<String> list = new ArrayList<>(Arrays.asList("Toy", "Box", "Robot", "Box")); // Arrays.asList("Toy", "Box", "Robot", "Box") => 이 리스트의 값을 해치지 않음

3) Set<E> 인터페이스를 구현하는 컬렉션 클래스들 : <- HashSet<E> / LinkedHashSet<E> (X) / SortedSet<E> (인터페이스 X) <- TreeSet<E>
- 클래스 불러오기 :  import java.util.Set ( HashSet / ArrayList / Iterator / TreeSet / Comparator)
- Set<E> 인터페이스를 구현하는 컬렉션 클래스의 공통적 특징 
 ㄴ> 저장 순서가 유지되지 않는다.
 ㄴ> 데이터의 중복 저장을 허용하지 않는다.
- 중복된 인스턴스를 삭제하려면 Set<E>을 구현하는 클래스에 넣었다가 빼면 된다. (컬렉션 클래스의 생성자를 사용) // List -> Set -> List

HashSet<E>
- 사용법 : add(<E>형 값) : 데이터 추가 | clear() : 데이터 전부 삭제 | remove(<E>형 값) : 데이터 삭제 | size() : 데이터 길이 및 크기 | contains(<E>형 값) : 데이터 검색
- 탐색은 Iterator<T> 쓰면 됨
- 저장 순서가 유지되지 않고 중복저장이 허용되지 않음 -> 그렇다면 동일데이터로 인스턴스를 판단하는 기준은 무엇일까?
 ㄴ> 같은 값을 지닌 두개의 다른 인스턴스는 Set에서 중복 값이라고 인지하지 않음 => 그래서 중복삭제 되지 않음 // 해쉬알고리즘과 hashCode 메소드
 ㄴ> 두 인스턴스를 같은 인스턴스라고 보는 기준은 Object 클래스에 정의되어 있는 equals() 메소드와 hashCode() 메소드의 호출결과로 이어짐

- 해쉬알고리즘과 hashcode메소드
ㄴ 해쉬알고리즘은 어떠한 값들을 해쉬알고리즘(특정 수식)을 통해서 동일 집단으로 분류한다. => hashCode()
ㄴ 탐색 1단계 : Object 클래스에 정의된 hashCode 메소드의 반환 값을 기반으로 부류 결정
ㄴ 탐색 2단계 : 선택된 부류 내에서 equals 메소드를 호출하여 동등 비교
 => Object 클래스의 hashCode 메소드는 인스턴스가 저장된 주솟값을 기반으로 반환 값을 결정한다. 
 => 인스턴스가 다르면 Object 클래스의 hashCode 메소드는 다른 값을 반환한다.
 => 인스턴스가 다르면 Object 클래스의 equals 메소드는 false를 반환한다.

ㄴ> 따라서 임의로 정한 기준으로 동등 여부를 따지도록 하려면 hashCode() 메소드와 equals 메소드를 오버라이딩 해야한다.
ㄴ> hashCode()를 오버라이딩 할 때 인스턴스의 멤버의 hashCode() 함수를 다시 불러서 hashCode() 함수를 오버라이딩 할 수 있다. 
  => public int hashCode() {  return (model.hashCode() + color.hashCode()) / 2 ; }
ㄴ> 또한 Objects 클래스에 정의된 메소드 hash를 부르고 인자에 해쉬알고리즘에 사용될 기준 값들을 부여하여 hashCode() 함수를 오버라이딩 할 수 있다.
  => public int hashCode() {  return Objects.hash(model, color) ; } 

TreeSet<E>
- 사용법 : add(<E>형 값) : 데이터 추가 | clear() : 데이터 전부 삭제 | remove(<E>형 값) : 데이터 삭제 | size() : 데이터 길이 및 크기 | contains(<E>형 값) : 데이터 검색
- 탐색은 Iterator<T> 쓰면 됨
- 저장 순서가 유지되지 않고 중복저장이 허용되지 않음 -> 그렇다면 동일데이터로 인스턴스를 판단하는 기준은 무엇일까? => 이진 탐색	법?
- 정렬된 순사가 유지되면서 인스턴스가 저장된다. => 정렬의 기준은 무엇일까? => 인스턴스들의 참조 순서는 오름차순을 기준으로 한다.
 ㄴ> 멤버가 여러게인 인스턴스는 기준을 어떻게 정하느냐에 따라서 오름차순으로의 나열 결과는 달라진다. 

- Comparable <T> 의 정렬 기준 제시
 => 일반적으로 정렬기준이 정해진 클래스(자료형) 에 대해 사용자가 원하는 정렬기준을 제시해 줄 수 있음
 ㄴ> public interface Comparable <T> => 이 인터페이스에 위치한 유일한 추상 메소드 int compareTo (T o) 
 ㄴ> 클래스 정의시 Compareble<T> 구현 + compareTo 메소드 오버라이딩
  => 인자로 전달된 o가 작다면 양의 정수 반환
  => 인자로 전달된 o가 크다면 음의 정수 반환
  => 인자로 전달된 o가 같다면 0을 반환

- Comparator<T> 의 정렬 기준 제시
 => 이미 사용자가 오버라이딩한 정렬 기준이 있는 클래스(자료형) 에 대해 새로운 정렬 기준을 부여 해줄 수 있음
 ㄴ> public interface Comparator<T> => int compare(T o1, T o2)의 구현을 통해 정렬 기준을 결정할 수 있다.
 ㄴ> Comparator<T>을 구현하는 새로운 클래스를 생성 + 내부에 메소드 int compare(T o1, T o2) 를 정의
 ㄴ> public TreeSet( Comparator< ? super E > comparator ) : TreeSet<E> 생성자에 Comparator<T>을 구현하는 클래스의 인스턴스를 생성 
  => < ? super E> 이기 때문에 인자의 값을 이용해서 compare() 메소드에서 값을 반환받아 그 원리로 값을 정렬 (수정 변경 가능)
 ㄴ> int compare(T o1, T o2)
  => o1이 o2보다 크다면 양의 정수 반환
  => o1이 o2보다 작으면 음의 정수 반환
  => o1과 o2가 같다면 0을 반환

4) Queue<E> 인터페이스를 구현하는 컬랙션 클래스들 : <- PriorityQueue<E> (X) / Deque<E> (인터페이스) <- LinkedList<E> / ArrayDeque<E> 
- 스택 : LIFO ( 마지막에 넣은 게 제일 처음 나옴 => 처음 넣은게 제일 마지막에 나옴)
- 큐 :  FIFO ( 처음 넣은게 제일 처음 나옴)

큐의 구현 : Queue<E>는 LinkedList<E> 로 구현되어 있다
- boolean add (E e)  : 넣기       => 	boolean offer(E e)  : 넣기, 넣을 공간이 부족하면 false 반환
- E remove() 	  : 꺼내기    => 	E poll()		: 꺼내기, 꺼낼 대상 없으면 null 반환
- E element() 	  : 확인하기  => 	E peek()		: 확인하기, 확인할 대상이 없으면 null 반환
ㄴ> add, remove, element 보다 offer, poll, peek 사용!

스택의 구현 : Deque<E>는 ArrayDeque<E>나 LinkedList<E>로 구현 되어 있다. 
- Stack<E>(상위 Vector<E>) 클래스가 있지만 자바 초기에 정의되었고 지금은 호환성 유지를 위해 존재.. 
- Stack<E> 는 동기화된 클래스로 멀티쓰레드에 안전하지만 그만큼 성능 저하가 발생.. 대신해서 Deque<E> 클래스를 사용한다.

 => void addFirst(E e)  :  앞으로 넣기		=> 	boolean offerFirst(E e)	:  앞으로 넣기, 공간 부족하면 false 반환
 => E removeFirst()     :  앞으로 꺼내기	=>	E pollFirst()		:  앞으로 꺼내기, 꺼낼 대상 없으면 null 반환
 => E getFirst()	     :  앞으로 확인하기	=>	E peekFirst()		:  앞으로 확인하기, 확인할 대상 없으면 null 반환
 => void addLast(E e)  :  뒤로 넣기		=>	boolean offerLast(E e)	:  뒤로 넣기, 공간 부족하면 false 반환
 => E removeLast()     :  뒤로 꺼내기		=>	E pollLast()		:  뒤로 꺼내기, 꺼낼 대상 없으면 null 반환
 => E getLast()	     :  뒤로 확인하기	=>	E peekLast()		:  뒤로 확인하기, 확인할 대상 없으면 null 반환

ㄴ> add, remove, element 보다 offer, poll, peek 사용!
ㄴ> 이것은 Dequq의 특성이고 이것을 스택으로 쓰려면 한쪽 문을 닫아서 사용해야한다. 
  => offerFirst & pollFirst : 앞으로 넣고 앞에서 꺼내기 / offerLast & pollLast : 뒤로 넣고 뒤로 꺼내기
ㄴ> 원래 스택에서는 넣는 것을 push, 빼는 것을 pop이라고 한다. 따라서 그렇게 하고 싶다면 Stack을 따로 구현해서 내부에서 Deque를 사용하면 된다. (캡슐화)

5) Map<K, V> 인터페이스를 구현하는 컬렉션 클래스들 : <- HashMap<K, V> / HashTable<K, V> (X) / SortedMap<K, V> (인터페이스 X) <- TreeMap<K, V>
- Key와 Value가 하나의 쌍을 이루는 데이터 저장 방식이다
- Key는 중복될 수 없다. 반면 Key만 다르다면 Value는 중복되어도 상관없다.
- HashMap<K, V>과 TreeMap<K, V>이 있는데 둘의 차이는 트리 자료구로 기반된 TreeMap<K, V>는 정렬 상태를 항상 유지한다는데 있다. 정렬의 대상은 key이다.

HashMap<K, V> vs TreeMap<K, V>
- key와 value도 인스턴스여야한다.
- put(<K>형 자료형, <V>형 자료형) : key와 value 저장 | get(<K>형 자료형) : key를 통한 값 꺼내기 | remove(<K>형 자료형) : key를 통한 삭제

- HashMap<K, V>과 TreeMap<K,V> 의 순차적 접근 방법
ㄴ> HashMap<K, V> 는 Collection<E>의 하위 인터페이스가 아니며 Iterable<T> 인터페이스를 구현하지 않는다. 따라서 for-each나 iterator(반복자)를 사용할 수 없다.
ㄴ> 대신에 Map<K, V>에는 다음 메소드가 존재한다.
  => public Set<K> keySet() : 이 메소드는 Set<E>를 구현하는 컬렉션 인스턴스를 생성하고 Map<K,V>의 모든 키를 반환한다. // Set<E>는 for-each & iterator을 사용할 수 있다.
  => 따라서 모든 키를 반환받은 Set<E>를 통해서 반복을 돌리면 모든 값을 참조할 수 있다. (순차적 접근)

- TreeMap<K, V>의 Comparator<T> 인터페이스를 기반으로 정렬 기준 설정
ㄴ> TreeSet<E>에서 했던 것과 동일한 방법으로 이미 사용자가 오버라이딩했거나 정렬 기준 정해져 있는 클래스(자료형) 에 대해 새로운 정렬 기준을 부여 해줄 수 있음
ㄴ> 정렬 되는 것은 value가 아니라 key값의 기준으로 정렬 된다.

----------------------- 24 단원 : 컬렉션 프레임워크 2 ----------------------------------------

1) 컬렉션 기반 알고리즘

정렬 : List<E>를 구현한 컬렉션 클래스들은 저장된 인스턴스를 정렬된 상태로 유지하지 않는다. => sort() 메소드 사용
- public static <T extends Comparable<T>> void sort( List<T> list ) 
 => 인자로 List<T>의 인스턴스는 모두 전달 가능.
 => 단, T는 Comparable<T> 인터페이스를 구현한 상태이어야 한다.
 => T가 String이라면 String클래스의 compareTo 메소드는 사전 편찬순으로 정렬되도록 구현되어 있다 => Comparable<T> 구현

<T extends Comparable<T>> 아니고 <T extends Comparable<? super T>> 
- 사실은 public static <T extends Comparable<T>> void sort( List<T> list ) 가 아닌
ㄴ> public static <T extends Comparable<? super T>> void sort( List<T> list )
 => 인자로 List<T>의 인스턴스는 모두 전달 가능
 => 단, T는 Comparable<? super T> 인터페이스를 구현한 상태이어야 한다.
 => <? super T> 인 이유는 T를 상속하는 하위클래스에서도 Comparable<T>을 간접 구현하기 때문에 그 클래스에게도 sort 메소드의 사용 가능성을 열어두기 위함
 => ex) Car 클래스에서는 Comparable<T>를 구현하고 있고 ECar 클래스에서는 Comparable<T>을 직접 구현하고 있지 않다. 하지만 ECar은 Car을 상속하고 있다.
 =>      따라서 ECar도 Comprable<T>를 간접 구현하고 있기 때문에 sort 메소드를 사용할 수 있도록 해야한다. 따라서 Comparable<T> 가 아닌 Comparable<? super T> 이다.

※ Comparable<T> 기반 sort 메소드는 T가 Comparable을 직(간)접적으로 구현하고 있기 때문에 그 Comparable 메소드의 기준에 따라 List를 받아 정렬함

정렬 : Comparator<T> 기반
- Collection 클래스에는 Comparator<T> 기반 sort 메소드도 정의되어 있다. 이는 호출시 정렬의 기준을 결정할 수 있다. 
ㄴ> public static <T> void sort(List<T> List, Comparator<? super T> c) => 제네릭 메소드
ㄴ> 인자 중 Comparator<? super T> c 는 매개변수 c를 대상으로는 T형 인스턴스를 넣는(전달하는) 메소드 호출만 OK
ㄴ> 즉 Comparator<? super T> c 인 내용을 변경하며 반환받는 값으로 정렬을 진행하겠다는 의미
ㄴ> <? super T> 선언이 주는 두번째 의미 : T의 하위 클래스의 정렬도 허용하겠다는 의미이다.

※ Comparator<T> 기반 sort 메소드는 List를 받고, Comparator<T>를 구현하는 클래스를 받아서 Comparator<T> 내부의 기준에 따라 List를 정렬함

찾기 : 리스트 자료구조 기반으로 특정 인스턴스를 찾을 때 사용할 수 있는 메소드가 Collections 클래스에 있다 => binarySearch()
- public static <T> int binarySearch(List<? extends Comparable<? super T>> list, T key) => 인덱스를 찾아서 리턴한다. key는 값이다.
=> 첫 번째 인자로 List<E> 인스턴스는 무엇이든 올 수 있다.
=> 단 , 이때 E는 Comparable<T>를 구현해야한다.
=> 여기서 Comparable<T>에 T 는 <? super T> 이다 그런 이유는 T의 하위 클래스에서도 Comparable<T>를 간접 구현하고 있기 때문에 binarySearch()의 사용을 열어 둬야한다.
ㄴ> 리스트는 정렬된 상태에서 binarySearch()를 실행해야한다. 그렇지 않으면 원하는 결과를 얻지 못한다.

※ list 에서 Key를 찾아 그 인덱스 값 반환, 못찾으면 음수 반환 / 그 리스트에서 T는 Comparable을 직,간접적으로 구현해야하며 Comparable 내의 메소드를 기준으로 찾음

찾기 : Comparator<T> 기반 
- Collections 클래스에는 Comparator<T>를 구현하는 클래스를 정의하여 탐색의 기준을 마련할 수 있는 binarySearch() 메소드를 지니고있다.
ㄴ>public static <T> binarySearch(List<? extends T> list, T key, Comparator<? super T> c)
=> List<T>아니고 List<? extends T> 인 이유는 list에서 T형 인스턴스를 꺼내는 것만 허용하기 위해
=> Comparator<T> 아니고 Comparator<? super T>인 이유는 T를 직,간접적으로 상속한 클래스들에게대 허용하기 위함

※ list 에서 Key를 찾는데 c의 기준을 적용해서 찾는다. 그 인덱스 값 반환, 못찾으면 음수 반환 / 리스트는 참조전용으로만 사용하고, Comparator은 하위클래스들을 직간접적으로 허용하기 위함

복사하기
- 다음은 리스트 구조의 컬렉션 인스턴스에 저장된 내용을 복사하는 기능의 메소드이다. => copy() 
ㄴ> public static <T> void copy(List<? Super T> dest, List<? extends T> src)  => src의 내용을 dest로 복사
=> List<T> dest 아닌 List<? super T> dest 인 이유는? dest에 T형 인스턴스를 넣는 것만 허용하겠다. 꺼내면 컴파일 에러!
=> List<T> src 아닌 List<? extends T> src 인 이유는? src로부터 T형 인스턴스 꺼내는 것만 허용하겠다. 넣으면 컴파일 에러!
ㄴ>주의! dest에 전달되는 컬렉션 인스턴스의 저장공간이 src에 전달되는 컬렉션 인스턴스의 저장공간 보다 크거나 최소한 같아야 한다. => 자동으로 늘지 않고 예외 발생!!

※ src의 내용을 dest로 복사하는데, src는 읽기 전용 / dest는 쓰기 전용

----------------------- 25 단원 : 열거형, 가변인자 그리고 어노테이션 -----------------------

1) 열거형
- 열거형은 의미가 부여된 이름을 갖는 상수
- 과거의 열거형은 하나의 인터페이스로 묶어서 선언하였다. (인터페이스 내에 선언된 변수는 public, static, final이기 때문)
ㄴ하지만 이는 특정 인터페이스 변수의 값이 일반적인 정수값으로 되어 있기 때문에 다른 인터페이스의 변수와 값이 겹처 비정상적인 결과가 일어남 (컴파일 에러 X, 실행 에러 X)
- 앞의 문제점을 해결하기 위해 열거형(enum EnumName{ }) 이 탄생함.
ㄴ 열거형은 클래스와 성격이 유사하다. 따라서 참조변수의 선언도 가능하며 단 이 참조변수에는 같은 열거형 값만 담을 수 있다. ex) Scale sc = Scale.DO;
ㄴ 앞의 문제점은 같은 열거형끼리의 대입이 가능하다는 점에서 해결된다. ex) Animal ni = Person.MAN => (컴파일 에러)

- 클래스 내에 클래스를 정의할 수 있다.(26단원 내용) -> 클래스 내에 열거형(일종의 클래스)을 정의할 수 있다. (클래스 내부에서 사용하는 열거형 값)

- 열거형은 클래스의 종류중 하나이며, 열거형 값은 자신의 클래스 내에서 public static final로 선언한 자신의 인스턴스이다.
ㄴ 자신의 클래스 내에서 자신의 클래스형의 참조변수의 선언 인스턴스 생성이 가능하다. ex) 
ㄴ 모든 열거형은 java.lang.Enum<E> 클래스를 상속하며 Enum<E>는 Object 클래스를 상속한다. 즉 열거형은 클래스이다.
ㄴ 열거형도 생성자가 따로 없으면 디폴트 생성자가 삽입된다. (하지만 열거형의 생성자는 private이다.)
 => 열거형도 생성자를 오버로딩(private 선언), 메소드 정의, 멤버변수 정의, 메소드 오버라이딩 모두 가능하다. 하지만 열거형 값을 정의할때 생성자 인자로 값을 넣고 싶다면 열거형 값에 괄호를 씌워서 값을 넣어주면 된다. ex) MAN(29)
ㄴ 따라서 고유의 참조값(인스턴스 값, 주소값)을 지니기 때문에 다른 값들과 겹칠수 없다.
ㄴ 모든 생성자를 private으로 선언해야하기 때문에 열거형 값이 유일한 인스턴스 생성 방법이다.

2) 매개변수의 가변 인자 선언
- 그냥 편리하게 사용할 수 있도록 바꾼 것, 의미는 같다.
- 함수의 정의의 매개변수: 
ㄴ일반적 => public static void showAll(String[] vargs) {
ㄴ가변인자 => public static void showAll(String...vargs) {
- 함수에 할당되는 인자 : 
ㄴ일반적 => showAll(new String[]{"Box"});
ㄴ가변인자 => showAll("Box00");

3) 어노테이션 
- 자바가 컴파일러에게 메시지를 전달하는 목적의 메모이다. 
- 기본만 배운다. www.jcp.org에 더 많은 것이 있다.
- @Override
ㄴ 오버라이딩 한다는 것을 컴파일러에게 알리고 컴파일러는 이것이 오버라이딩 안되었으면 에러를 일으킴
ㄴ 상위 클래스의 메소드 오버라이딩 또는 인터페이스에 선언된 추상 메소드의 구현에 사용할 수 있다.
- @Deprecated
ㄴ 문제의 발생 소지가 있거나 개선된 기능의 다른 것으로 대체되어서 더 이상 필요 없게 되었음을 뜻함.
ㄴ 호환성 유지로 존재하나 이후에 사라질 가능성이 있는 클래스와 메소드를 Deprecater 되었다고 한다.
ㄴ 컴파일러가 Deprecated 된 무언가를 사용했음을 알려주며 그 문장을 경고한다.

- @SuppressWarnigs
ㄴ @SuppressWarnigs 선언을 통해 컴파일러의 경고를 지울 수 있다. (경고 메시지를 전달하지 않도록 요청)
ㄴ @SuppressWarnigs(" ") // " " 내부에 경고에 대한 이름을 넣어서 경고를 지울 수 있다. ex) @SuppressWarnigs("deprecation")
ㄴ 둘 이상의 경고문을 지울려면 @SuppressWarnigs({" ", " "}) 이렇게 나열 해주면 된다. ex) @SuppressWarnigs({"fallthrough", "deprecation"})

----------------------- 26 단원 : 네스티드 클래스와 람다 -------------------------------------

1)네스티드 클래스와 이너 클래스
- 네스티드 클래스란 클래스 내부에 정의된 클래스를 네스티드 클래스라고 한다.
- class OuterClass {
	static class StaticNest{... } 	// Static 네스티드 클래스
	class InnerClass{...} 		// 이너 클래스(네스티드 클래스)
}

Static 네스티드 클래스
- 자신을 감싸는 외부 클래스의 인스턴스와 상관없이 Static 네스티드 클래스의 인스턴스 생성이 가능하다. ex) Outer.Nested nst = new Outer.Nested();
- - Static 네스티드 클래스 내에서 외부 클래스의 인스턴스 변수와 메소드에 접근 불가능하다. 따라서 외부 클래스의 static으로 선언된 멤버변수만 사용할 수 있다.
ㄴ 외부 클래스의 static으로 선언한 멤버 변수를 내부 클래스에서 공유할 수 있다. 
ㄴ 외부 클래스의 private static으로 선언한 멤버 변수를 내부 클래스에서 공유할 수 있지만 외부클래스 밖에서는 사용할 수 없다.

Non-static 네스티드 클래스 (이너 클래스)
- 멤버(이너)클래스 [인스턴스 변수, 인스턴스 메소드와 동일한 위치에 정의] / 로컬(이너)클래스 [중괄호 내에, 특히 메소드 내에 정의] / 익명(이너)클래스 [이름이 없는 클래스]

- 멤버 (이너) 클래스
ㄴ 멤버 클래스는 외부 클래스의 인스턴스 변수, 인스턴스 메소드와 동등한 위치에서 정의되는 클래스이다.
ㄴ 멤버 클래스 내에서는 외부 클래스의 인스턴스 변수에 접근이 가능하다. (private로 되있어도 가능)
ㄴ 멤버 클래스의 인스턴스는 외부 클래스의 인스턴스에 종속적이다.
ㄴ 참조변수 및 인스턴스 생성 : ex) Outer o1 = new Outer();  Outer.Member o1m1 = o1.new Member(); 
 => 외부 인스턴스 생성 후 그 인스턴스의 멤버연산자로 new를 사용해서 인스턴스 생성, 참조변수도 외부클래스의 멤버연산자로 멤버클래스의 참조변수를 정의
ㄴ 멤버 클래스의 인스턴스 들은 해당 외부 클래스의 인스턴스 변수와 메소드를 공유한다.

- 언제 유용하게 사용? => 클래스의 정의를 감추어야 할 때 유용하게 사용된다.
ㄴ 1. 멤버 클래스를 private로 정의한다. => 멤버 클래스를 정의한 외부 클래스 내에서만 멤버 클래스의 인스턴스 생성이 가능하다.
ㄴ 2. 외부 클래스의 메소드에서 멤버 클래스의 인스턴스 생성을 반환한다.
ㄴ 3. 멤버 클래스는 특정 인터페이스를 구현한 클래스이다. => 인터페이스 참조변수에 외부 클래스의 메소드를 대입해서 인스턴스를 생성할 수 있게 된다.
ㄴ 4. 인터페이스 참조변수는 자신의 인터페이스를 구현한 클래스의 정의를 감추고도 자신의 추상메소드를 보고 그 클래스를 사용할 수 있다.
=> 클래스의 정의가 감추어진 상황 // 멤버 클래스의 정의가 변경되거나 다른 클래스의 인스턴스로 변경되어도 인터페이스의 사용에는 변함이 없다.
=> 즉 코드의 유연성이 부여되었다 => 큰 장점이다.

- 로컬 (이너) 클래스
ㄴ 로컬 클래스는 외부 클래스의 중괄호(if, while ,메소드 등 블록) 내에 정의되는 클래스인데 대부분 메소드 안에서 정의된다.
ㄴ 로컬 클래스는 바로위에서 소개한 멤버 클래스와 상당 부분 유사하다.
ㄴ 로컬클래스는 해당 메소드 내에서만 인스턴스 생성이 가능하다. (로컬클래스의 수명이 메소드 내부임을 이용한 것이다.)
ㄴ private 선언은 의미가 없고 멤버 클래스 보다 클래스를 더 깊이 감추는 효과가 있다.
ㄴ 메소드의 반환값이 생성된 로컬 클래스의 인스턴스이다.

- 익명 (이너) 클래스
ㄴ 람다와 관련이 있다.
ㄴ 클래스 정의와 인스턴스 생성문 한번에 묶는다. 
=> 원래 인터페이스는 인스턴스를 생성할 수 없지만 인스턴스 생성 뒤에 중괄호로 클래스 정의를 덧붙이면 인스턴스 생성이 가능하다.
=> ex) interface Printable() {... } // return new Printable(){ ... } => 익명 클래스 (이름이 없다. 클래스의 정의만 있다.)

2) 람다의 소개
- 익명 (이너) 클래스 => 람다
- 람다를 사용하면 코드를 줄일 수 있다. 그리고 그 코드는 가독성도 뛰어나다.
- 쉽게 말하면 익명 클래스의 코드를 람다식으로 줄여놓은 것을 말한다. (하지만 람다와 익명클래스의 내부 동작 원리는 다르다.)
- 익명 클래스 ex) 					람다 ex) 
   Printable prn = new Printable() {			  Printable prn = (s) -> { System.out.println(s); }; 
	public void print(String s){		=>
		System.out.println(s);
	}
   }
- 람다와 익명클래스는 다르다. 그러나 둘 다 인스턴스의 생성으로 이어지고, 람다식이 익명 클래스의 정의를 일부 대체하기 때문에 익명클래스를 기반으로 람다를 이해하는 것은 좋은 방법이다.
ㄴ 람다는 메소드 1가지만 표현할 수 있다. 익명 클래스는 클래스이기 때문에 변수와 메소드를 여러개 지닐 수 있다.
- 유추 가능한 부위 삭제 : new Printable() : 삭제 [참조변수형] => public void print(String s) : 삭제 [인터페이스에 이미 정의되어 있음] ( - ) => (String s) -> : 추가 [s가 매개변수임을 인지 못함] -> String : 삭제 [매개변수 형은 유추가능] 
=> 결과 : (s) -> { System.out.println(s); }; 
- 람다식을 매개변수의 인자로 전달할 수 있다. 
ㄴ 매개변수 형이 인터페이스 참조변수형이라면 대입도 가능하기 때문에 함수의 인자로 전달 가능하다.

----------------------- 27 단원 : 람다 표현식 --------------------------------------------------

- 람다식을 정의하는 것과 사용하는 것은 다르다.
- 람다식을 적는 다는 것은 추상메소드를 구현(오버라이딩, 정의)하는 것이다.
- 사용할때 그 메소드를 불러서 사용함.

1) 람다와 함수형 인터페이스
- 기능 하나를 정의해서 전달해야 하는 상황 / 인스턴스를 전달하는 형태이지만 내용을 보면 메소드, 즉 기능을 전달한다.
- 인터페이스에는 추상메소드가 딱 하나만 존재한다 => 함수형 인터페이스 (@FunctionalInterface) 
ㄴ 람다식은 이러한 함수형 인터페이스를 기반으로 작성이 될 수 있다.
ㄴ@FunctionalInterface : 함수형 인터페이스가 적합한지 확인해주고 아니라면 컴파일 에러를 일으키는 어노테이션 // static이나 default 선언이 붙은 메소드는 제외 ( 람다식을 작성할 때 제외된다.)
- 람다 작성법 : 
ㄴ 매개변수의 자료형을 지울 수 있다.	ex) (String s) -> { System.out.println(s); }; => (s) -> { System.out.println(s); };
ㄴ 메소드 몸체가 하나의 문장으로 이루어져 있다면 중괄호와 세미콜론을 지울 수 있다.	ex) (s) -> { System.out.println(s); };  =>  (s) -> System.out.println(s);
ㄴ 매개변수의 인자가 한개라면 소괄호를 지울 수 있다. (두개라면 가능 X)	ex) (s) -> System.out.println(s);  =>  s -> System.out.println(s);
ㄴ 메소드 몸체가 하나의 문장이고 반환하는(return) 문장이라면 return 키워드 삭제 가능	ex) (a, b) -> { return a + b; };	  =>  (a, b) -> a + b;
ㄴ 매개변수가 없는 람다식은 소괄호를 적되 안을 비우면 된다.	ex) () -> System.out.println("Hello lambda");
ㄴ 인터페이스는 제네릭으로 정의하는 것이 가능하다. 따라서 이를 람다식과 함께 사용할 수 있다.	ex) interface Calculate<T> { T cal(T a, T b); }   .... Calculate<Integer> ci = (a, b) -> a + b;  ... ci.cal(4, 3);

2) 정의되어 있는 함수형 인터페이스
- 제네릭 인터페이스( <T> ) 이자 함수형 인터페이스( default, static 제외 메소드 1개)
- java.util.function 패키지로 묶여 있음. 

- Predicate<T> 인터페이스의 추상메소드    boolean test(T t) 
ㄴ 전달 된 인자를 판단하여 true 또는 false를 반환해야 하는 상황에서 유용하게 사용
ㄴ boolean test(T t) 메소드 정의에 해당하는 람다식을 작성해서 전달해야한다.
ㄴ ex) Predicate<Integer> p = n -> n % 2 == 0; 	// 람다식 / 추상메소드의 정의 (일시적 / 식을 도중에 바꿀 수 있음)
         System.out.println(p.test(3)); 	=> false		// 메소드 사용
ㄴ Predicate<T>를 구체화하고 다양화한 인터페이스들
 => IntPredicate : 인터페이스 / boolean test(int value) : 추상메소드 
 => LongPredicate : 인터페이스 / boolean test(long value) : 추상메소드
 => DoublePredicate : 인터페이스 / boolean test(double value) : 추상메소드  // 여기까진 함수인터페이스지만 제네릭은 아님
 => BiPredicate<T, U> : 인터페이스 / boolean test(T t, U u) : 추상메소드	// 둘다 맞음

- Supplier<t> 인터페이스의	추상메소드     T get()
ㄴ 단순히 무언인가를 반환할 때 유용하게 사용한다.
ㄴ T get() 메소드 정의에 해당하는 람다식을 작성해서 전달해야한다.
ㄴ 동일한 특정 값을 담거나 1씩 증가하는 정수들을 담을 수도 있다.
ㄴ ex) Supplier<Integer> s = () -> new Random().nextInt(50);   // 람다식 / 추상메소드의 정의 (일시적 / 식을 도중에 바꿀수 있음)
         System.out.print(s.get()); => 1 ~ 50사이의 난수	       // 메소드 사용
ㄴ Supplier<T>를 구체화하고 다양화한 인터페이스들
 => IntSupplier : 인터페이스 / int getAsInt() : 추상메소드
 => DoubleSupplier : 인터페이스 / double getAsDouble() : 추상메소드
 => LongSupplier : 인터페이스 / long getAsLong() : 추상메소드
 => BooleanSupplier : 인터페이스 / boolean getAsBoolean() : 추상메소드	// 함수인터페이스이지만 제네릭 인터페이스는 아니다.

- Consumer<T> 인터페이스의 추상메소드   void accept(T t)
ㄴ 전달된 인자 기반으로 '반환' 이외의 다른 결과를 보일 때 유용하게 사용할 수 있다.
ㄴ void accept(T t) 메소드 정의에 해당하는 람다식을 작성해서 전달해야한다.
ㄴ ex) Consumer<String> c = s -> System.out.println(s);	     // 람다식 / 추상메소드의 정의(일시적 / 식을 변경가능)
         c.accept("Pineapple");     => "Pineapple" 출력	     // 메소드 사용
ㄴ Consumer<T>를 구체화하고 다양화한 인터페이스들 : T가 들어간 것은 모두 제네릭 / 모두 함수형 인터페이스
 => IntConsumer : 인터페이스 / void accept(int value) : 추상메소드
 => ObjIntConsumer<T> : 인터페이스 / void accept(T t, int value) : 추상메소드 
 => LongConsumer : 인터페이스 / void accept(long value) : 추상메소드
 => ObjLongConsumer<T> : 인터페이스 / void accept(T t, long value) : 추상메소드
 => DoubleConsumer : 인터페이스 / void accept(double value) : 추상메소드
 => ObjDoubleConsumer<T> : 인터페이스 / void accept(T t, double value) : 추상메소드
 => BiConsumer<T, U> : 인터페이스 / void accept(T t, U u) : 추상메소드  // 제네릭 인자 2개를 받아서 사용
 
- Function<T, R> 인터페이스의 추상메소드  R apply(T t)
ㄴ 전달 인자와 반환 값이 모두 존재, 가장 보편적인 형태이다.
ㄴ R apply(T t) 메소드 정의에 해당하는 람다식을 작성해서 전달해야한다.
ㄴ ex) Function<String, Integer> c = s -> s.length();	     // 람다식 / 추상메소드의 정의(일시적 / 식을 변경가능)
         c.apply("Pineapple");     => 9 출력	        	     // 메소드 사용
ㄴ Function<T>를 구체화하고 다양화한 인터페이스들 : T가 들어간 것은 모두 제네릭 / 모두 함수형 인터페이스
 => 더 많지만 double과 int만 설명
 => IntToDoubleFunction : 인터페이스 / double applyAsDouble(int value) 추상메소드		// int -> double
 => DoubleToIntFunction : 인터페이스 / int applyAsInt(double value) 추상메소드		// double -> int
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 => IntUnaryOperator : 인터페이스 / int applyAsInt(int operand) 추상메소드			// int -> int
 => DoubleUnaryOperator : 인터페이스 / double applyAsDouble(double operand) 추상메소드	// double -> double
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 => IntFunction<R> : 인터페이스  / R apply(int value) : 추상메소드				// int -> R 
 => DoubleFunction<R> : 인터페이스  / R apply(double value) : 추상메소드			// double -> R
 => ToIntFunction<T> : 인터페이스  / int applyAsInt(T value) : 추상메소드			// T -> int
 => ToDoubleFunction<T> : 인터페이스  / double applyAsDouble(T value) : 추상메소드	// T -> double
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 => BiFuncton<T, U, R> : 인터페이스 / R apply(T t, U u) : 추상메소드			// T, U -> R
 => ToIntBiFuncton<T, U> : 인터페이스 / int applyAsInt(T t, U u) : 추상메소드		// T, U -> 
 => ToDoubleBiFuncton<T, U> : 인터페이스 / double applyAsDouble(T t, U u) : 추상메소드	// T, U -> R
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 => UnaryOperator<T> : 인터페이스 / T apply(T t) : 추상메소드				// T -> T
 => BinaryOperator<T> : 인터페이스 / T apply(T t1, T t2) : 추상메소드			// T, T -> T

- removeIf() 메소드 (디폴트 메소드)
ㄴ 인터페이스 : Collection<E>
ㄴ default boolean removeIf(Predicate<? super E> filter)
ㄴ 람다식을 인자로 받아서 true인 값들을 다 삭제하고 false인 값만 남긴다.
ㄴ ex) List<Integer> ls1 = new ArrayList<>(Arrays.asList(-1, 2, -3, 4, -5));
         ls.removeIt(n -> n.doubleValue() < 0.0); 
 => ls가 -1, -3,-5 를 삭제한 결과는 [2, 4] 이다.
 => n이 dobleValue 메소드를 쓸 수 있는 이유는 Predicate의 제네릭이 <? super E> 이기 때문이다. (E == Number, Object... )
 => Predicate<E>의 test()가 전달된 람다식을 통해서 true와 false를 반환하고 removeIf() 메소드 내부에서 그 값을 이용해서 삭제를 진행한다.

----------------------- 28 단원 : 메소드 참조와 Optional -------------------------------------

1) 메소드 참조
- 람다식은 결국 메소드의 정의 => 이미 정의가 되어 있는 메소드가 있다면, 이 메소드의 정의가 람다식을 대신할 수 있다.
- 과거 : 코드 가독성 중시 => 현재 : 코드의 양 줄이기 -> 생산성 향상, 가독성 개선
- 람다식 내에서 이미 정의되어 있는 메소드나, 클래스, 생성자를 사용할 수 있다.
- 람다식의 인자를 생략하고 '::' 연산자를 사용한다. 
ㄴ ex) l -> Collectons.reverse(l) => Collectons::reverse
ㄴ 함수형 인터페이스의 메소드에 전달될 인자를 그대로 정의되어 있는 메소드의 인자로 쓰기 때문에 인자를 생략할 수 있다.
ㄴ 람다식의 인자도, 정의된 메소드의 인자도 생략한다.

- static 메소드 참조 (클래스 메소드)
ㄴ ex) Consumer<List<Integer>> c = l -> Collectons.reverse(l); => Consumer<List<Integer>> c = Collectons::reverse(l);
ㄴ Collections라는 인터페이스(클래스)의 static 메소드 reverse(List<?> list)
ㄴ ClassName::staticMethodName

- 참조변수를 통한 인스턴스 메소드 참조 (인스턴스 메소드)
ㄴ ex) JustSort j = new justSort(); // Consumer<List<Integer>> c = (e) -> j.sort(e)   =>   Consumer<List<Integer>> c = j::sort
ㄴ JustSort라는 클래스의 인스턴스 j의 (인스턴스) 메소드 sort(List<?> list)
ㄴ 람다식에서 접근 가능한 참조변수는 final로 선언되었거나 effectively final이어야 한다.
ㄴ 초기화 된 이후에 값이 한번도 변경되지 않았다면 effectively final이다 => 사실상 final // 참조변수에 값을 변경하지 않아야 한다.
ㄴ ReferenceName::instanceMethodName

ㄴ forEach() 메소드 (디폴트 메소드)
 => 인터페이스 : Iterable<T> // 인스턴스 메소드
 => default void forEach(Consumer<? super T> action) {
	for(T t : this)	// this는 이 메소드가 속한 컬렉션 인스턴스를 의미
	    action.accept(t);	 // 모든 저장된 데이터들에 대해 이 문장 반복
     }
 
- 클래스 이름을 통한 메소드 참조
ㄴ ex) ToIntBiFunction<IBox,IBox> bf = (b1, b2) -> b1.larger(b2);  =>  ToIntBiFunction<IBox,IBox> bf = IBox::larger;
ㄴ 이렇게 줄일 수 있는 이유는 ToIntBiFunction 인터페이스의 추상메소드에 인자의 순서대로 수행해야할 내용이 정의되어 있는 약속이 있기 때문에 줄일 수 있음.. 컴파일러가 알아서 매칭시킴
ㄴ ClassName::instanceMethodName

- 생성자 참조
ㄴ ex) Function<char[], String> f = ar -> new String(ar)  =>  Function<char[], String> f = String::new; 
ㄴ 람다식을 이루는 문장이 '단순히 인스턴스의 생성 및 참조 값의 반환'일 경우 다음 형태의 메소드 참조로 바꿀 수 있다.
ㄴ Fuction<T,R> 인터페이스 추상메소드 apply의 약속 때문에 생략이 가능한 것
ㄴ ClassName::new

2) Optional 클래스

- NullPointerException 예외의 발생 상황
ㄴ 코드를 작성하고 실행하다 보면 NullPointerException 예외를 접할 수 있다. 
ㄴ 이 예외를 처리하려면 if( 변수 != null) 구문을 중첩해서 반복해야하는데 이걸 해결할 수 있는 클래스가 Optional 클래스이다.

- Optional 클래스의 기본적인 사용 방법
ㄴ import java.util.Optional
ㄴ public final class Optional<T> extends Object { private final T value; .... }  // value 에 인스턴스 저장하는 일종의 래퍼 클래스
ㄴ 제네릭 클래스,

ㄴ 클래스 메소드
=> Optional<T> op = Optional.of(new T());				// of 메소드, T형 인스턴스를 저장하는 Optional 인스턴스 생성,
=> Optional<T> op = Optional.ofNullable(new T());			// ofNullable 메소드, T형 인스턴스를 저장하는 Optional 인스턴스 생성, null도 저장가능
=> Optional<T> op = Optional.empty() (== Optional.ofNullable(null);)	// empty 메소드, null을 저장하는 Optional 인스턴스 생성, ofNullable 메소드에 null을 저장한 것과 동일

ㄴ인스턴스 메소드
=> public T get() 							// Optional 인스턴스 내부에 저장했던 인스턴스를 꺼내줌
=> public boolean isPresent() 					// 인스턴스에 내용물이 있는지 확인, 있으면 True 없으면 false 반환

=> public void ifPresent(Consumer<? super T> consumer)    
  ㄴ> [ Consumer<T>    // void accept(T t) ]
  ㄴ> ifPresent 내부에서 Consumer<T> 인터페이스의 accept() 메소드 호출  => 인자를 받아서 결과를 보이는 메소드
  ㄴ> Consumer<T> 인터페이스의 accept() 메소드는 추상메소드이므로 람다식을 괄호안에 정의해야함
  ㄴ> Optional 인터페이스에 값이 있다면(null이 아니라면) 람다식을 실행
  ㄴ> if 문이 사라짐 -> 엄청난 큰 의미, 문장이 깔끔해짐

=> pulbic <U> Optional<U> map(Function<? super T, ? extends U> mapper)   
  ㄴ> [ Function<T, U>    // U apply(T t) ]
  ㄴ> map 내부에서 Function<T,U> 인터페이스의 apply() 메소드를 호출 => 인자를 받아서 연산 결과를 반환하는 메소드
  ㄴ> Function<T,U> 인터페이스의 apply() 메소드는 추상메소드이므로 람다식을 괄호안에 정의해야함
  ㄴ> 람다식을 통해서 나온 결과를 다시 Optional 클래스로 감싸서 반환함.
  ㄴ> 반환형이 Optional<U>이기 때문에 apply() 메소드가 반환하는 대상을 Optional 인스턴스에 담아서 반환함.  => 이는 map을 포함한 Optional 인스턴스 메소드를 이어서 사용이 가능하단 뜻임.
=> public <U> Optional<U> flatMap(Function<? super T,? extends Optional<? extends U>> mapper)
  ㄴ> [ Function<T, U>    // U apply(T t) ]
  ㄴ> 위의 메소드와 기능은 동일하지만 조금 다름
  ㄴ> map() 과 flatMap() 모두 Optional 인스턴스를 반환함. 하지만 flatMap() 알아서 내용물을 Optional 인스턴스로 감싸는 일을 해주지 않음 따라서 람다식이 따로 감싸야함
  ㄴ> 그래서 flatMap() 메소드는 Optional 인스턴스를 클래스 멤버로 둘 때 유용함 (Optional 클래스를 코드 전반에 사용할때)
  ㄴ> 위의 경우에서 map을 사용하게 되면 Optional 인스턴스를 한번더 Optional 인스턴스로 감싸기 때문에 get() 메소드를 사용해야하는 불편함이 있음 따라서 flatMap() 을 사용함

=> public T orElse(T other)
  ㄴ> get() 메소드와 비슷하게 Optional 인스턴스에 저장된 내용물을 반환함.
  ㄴ> 다른점은 저장된 내용물(null) 이 없을 때, 인자로 값을 부여하여 반환할 대상을 지정할 수 있음.
  ㄴ> map과 같은 메소드(Optional 인스턴스를 반환하는 메소드)와 함께 사용해서 if..else 문을 대신하고 간결한 문장을 만들 수 있음. 

- OptionalInt, OptionalLong, OptionalDouble 클래스 [ Optional과 OptionalXXX 와의 차이점 ]
  ㄴ> Optional 클래스보다 기능이 제한적이지만 다음 챕터의 stream에서는 이 클래스를 조금 접하게 된다.
  ㄴ> ex) Optional<Integer> => OptionalInt

----------------------- 29 ~ 30 단원 : 스트림 1, 2 ------------------------------------------------------

1) 스트림의 이해
- 스트림이란? 데이터의 흐름. 배열 또는 컬렉션 인스턴스에 저장된 데이터를 꺼내서 파이프에 흘려보낸다.
- 데이터 흐름 중 중간연산(마지막이 아닌 위치에서 진행되어야 하는 연산)과 최종연산(마지막에 진행이 되어야 하는 연산)이 있다.
- 스트림 연산은 지연 처리 방식으로 동작한다. 중간 연산이 아무리 많이 진행되더라도 최종연산이 진행되지않으면 아무런 결과가 나타나지 않는다. (최종연산이 없다면 의미가 없다)
- 중간연산은 생략하고 최종연산만 있어도 결과는 나타난다. 결국 중요한건 최종연산이다.
- 스트림은 최종연산을 하는 순간 '파이프 라인'의 마지막을 통과해버린다. 따라서 이미 흘러가버린 스트림을 대상으로는 그 어떤 연산도 추가로 진행할 수 없다. => 매번 새로 스트림을 생성해야한다.
- 흘러가는 스트림, 즉 중간연산의 결과 값을 저장하고싶다면 최종연산의 collect 메소드를 사용하면 된다.

2) 스트림의 생성과 연결

- 스트림의 생성 : 배열
 ㄴ java.util.Arrays에 stream 메소드가 오버로딩되어 있음.
 ㄴ제네릭 클래스를 만드는 메소드
 => 인자로 배열을 부여하여 제네릭 클래스인 스트림을 만든다.
 => public static <T> Stream<T> stream(T[] array)

 ㄴ기본자료형 클래스를 만드는 메소드
 => 각 자료형 배열을 첫번째 인자로 부여하고 각 자료형의 스트림을 만든다.
 => startInclusive와 endExclusive는 배열에서 일부만 가져오기 위해 시작과 끝을 정해서 그 만큼만 스트림으로 만들기 위한 인자이다.
 => startInclusive => 시작 / endExclusive => 마지막 -1
 => public static IntStream stream(int[] array, [ int startInclusive, int endExclusive ])
 => public static DoubleStream stream(double[] array, [ int startInclusive, int endExclusive ])
 => public static LongStream stream(long[] array, [ int startInclusive, int endExclusive ])

- 스트림의 생성 : 컬렉션 인스턴스
 ㄴ java.util.Collections<E>에 디폴트 메소드로 정의 되어 있음
 ㄴ default Stream<E> stream() // ex) list.stream() 

- 스트림의 생성 : 스트림 생성에 필요한 데이터를 직접 전달
 ㄴ 클래스 메소드임 => java.util.stream.Stream/IntStream/DoubleStream/LongStream
 ㄴ static <T> Stream<T> of(T t) 		=> 단일 전달 (기본자료형, 컬렉션 인스턴스)
 ㄴ static <T> Stream<T> of(T...values)	=> 복수 전달 (위의 것들의 배열)
 ㄴ static DoubleStream of(double t  / double...values) 		  	=> 단일 / 복수
 ㄴ static IntStream of(int t / int...values)	         		  	=> 단일 / 복수
 ㄴ static LongStream of(long t / long...values)			  	=> 단일 / 복수
 ㄴ static IntStream range(int startInclusive, int endExclusive)	  	=> start ~ end -1 까지의 수를 스트림으로
 ㄴ static IntStream rangeClosed(int startInclusive, int endExclusive)		=> start ~ end 까지의 수를 스트림으로
 ㄴ static LongStream range(int startInclusive, int endExclusive)		=> start ~ end -1 까지의 수를 스트림으로
 ㄴ static LongStream rangeClosed(int startInclusive, int endExclusive) 	=> start ~ end 까지의 수를 스트림으로
 ㄴ double은 실수이고 정수와 정수사이에 무수한 실수가 있기 때문에 안됨

- 스트림의 연결
 ㄴ 두 개의 스트림을 연결하여 하나의 스트림을 생성할 수 있음.
 ㄴ 클래스 메소드임 => java.util.stream.Stream
 ㄴ static <T> Stream<T> concat(Stream<? extends T> a, Stream<? extends T> b)
 ㄴ static DoubleStream concat(DoubleStream a, DoubleStream b)
 ㄴ static IntStream concat(IntStream a, IntStream b)
 ㄴ static LongStream concat(LongStream a, LongStream b)

3) 스트림의 중간 연산
- 반환 값이 Stream<T>이거나 기본자료형 스트림임
- 중간 연산은  몇번을 진행해도 상관없음

-필터링 
ㄴ filter()
=> Stream<T> 반환
=> Stream<T> filter(Predicate<? super T> predicate)	[ Predicate<T>	boolean test(T t) ]
=> filter 메소드 내부에서 람다식으로 정의된 Predicate<T>인터페이스의 test() 메소드 실행 
=> 내부적으로 데이터 하나씩 test() 메소드를 호출하며 람다식을 통해 true로 반환된 값들만 통과시킴

- 맵핑 - 제네릭 메소드
ㄴ map()
=> <R> Stream<R> map( Function<? super T, ? extends R> mapper )	[ Function<T,R>	R apply(T t) ]
=> IntStream mapToInt( ToIntFunction<? super T> mapper )		
=> LongStream mapToLong( ToLongFunction<? super T> mapper )	
=> DoubleStream mapToDouble( ToDoubleFunction<? super T> mapper )	
=> map 메소드 내부에서 람다식으로 정의된 Function<T, U>인터페이스의 apply() 메소드 실행 
=> 내부적으로 데이터 하나씩 apply() 메소드를 호출하며 람다식을 통해 바뀐 값들을 반환시켜 통과시킴

ㄴ flatMap()
=> <R> Stream<R> flatMap(Function<? super T, ? extends Stream<? extends R>> mapper)	[ Function<T, R>	Stream<R> apply(T t) ]
=> IntStream flatMapToInt(Function<? super T, ? extends IntStream> mapper) 
=> LongStream flatMapToLong(Function<? super T, ? extends LongStream> mapper) 
=> DoubleStream flatMapToDouble(Function<? super T, ? extends DoubleStream> mapper) 
=> map 메소드와 다르게 apply() 메소드의 반환 값이 Stream<R>이기 때문에 반환시 스트림을 생성해서 반환해야한다.
=> 그렇게 스트림으로 저장된 데이터들은 flatMap에서 스트림들이 합쳐져 하나의 스트림이 된다.
=> map은 1대 1 매핑 / flatmap은 1대 다 매핑

- 정렬
ㄴ sorted()
=> stream<T> sorted(Comparator<? super T> comparator)
 ㄴ> Comparator<T> 인터페이스의 compare 메소드에 람다식을 보내서 람다식의 기준으로 정렬
=> stream<T> sorted()
=> IntStream sorted()
=> LongStream sorted()
=> DoubleStream sorted()
 ㄴ> 알아서 정렬 (오름차순 or 내림차순 or 사전별)

- 루핑
ㄴ peek()
=> forEach() 메소드와 기능이 거의 같고 중간연산에 해당하는 메소드이다.
=> Consumer<T> 인터페이스의 accept() 메소드는 추상메소드이므로 람다식을 괄호안에 정의해야함
=> Stream<T> peek(Consumer<? super T> action)
=> IntStream peek(IntConsumer action)
=> LongStream peek(LongConsumer action)
=> DoubleStream peek(DoubleConsumer action)

4) 스트림의 최종 연산
- 반환 값이 기본자료형이나 참조자료형임 (stream으로 반환되지 않는다)

- 리덕션 : 데이터를 축소하는 연산
ㄴ reduce()
=> T reduce(T identity, BinatyOperator<T> accumulator)		[ BinaryOperator<T>	T apply(T t1, T t2) ]
=> 다른 리덕션 연산에 비해 활용도가 높음, 다른 연산과 다르게 reduce는 전달하는 람다식에 의해 연산 내용이 결정되기 때문
=> reduce의 연산은 (data1 + data2 = result) => (result + data3 = result2) => (result2 + data4 = result3) => .... 형식으로 값을 누적하며 진행한다.
=> reduce 메소드 내부에서 람다식으로 정의된 BinaryOperator<T>인터페이스의 apply() 메소드 실행
=> apply() 메소드에서 인자 둘을 가지고  연산을 한 뒤 하나의 결과를 반환함.
=> reduce() 메소드는 첫번째 인자로 전달된 값을 스트림이 빈 경우에 반환을 한다. 뿐만 아니라 스트림이 비어 있지 않은 경우에는 이를 스트림의 첫번째 값으로 인식하여 리덕션을 진행한다.

ㄴ sum(), count(), average(), min(), max()
=> IntStream의 메소드들 : int sum() / long count() / OptionalDouble average() / OptionalInt min() / OptionalInt max() 
=> DoubleStream의 메소드들 : double sum() / long count() / OptionalDouble average() / OptionalDouble min() / OptionalDouble max() 
=> LongStream의 메소드들 : Long sum() / long count() / OptionalDouble average() / OptionalLong min() / OptionalLong max() 

ㄴ allMatch(), anyMatch(), nonMatch() 		[ Predicate<? super T> 	boolean test(T t) ]
=> allMatch() : 스트림 안에 저장된 데이터 모두가 Predicate<T>의 test에 부합한가? 		true or false
=> anyMatch() : 스트림 안에 저장된 데이터 중 하나라도 Predicate<T>의 test에 부합한가?	true or false
=> noneMatch() : 스트림 안에 저장된 데이터 모두가 Predicate<T>의 test에 부합하지 않는가?	true or false
=> Stream<T> 메소드 
 ㄴ> boolean allMatch(Predicate<? super T> predicate)
 ㄴ> boolean anyMatch(Predicate<? super T> predicate)
 ㄴ> boolean noneMatch(Predicate<? super T> predicate)
=> IntStream 메소드
 ㄴ> boolean allMatch(IntPredicate predicate)
 ㄴ> boolean anyMatch(IntPredicate predicate)
 ㄴ> boolean noneMatch(IntPredicate predicate)
=> DoubleStream 메소드
 ㄴ> boolean allMatch(DoublePredicate predicate)
 ㄴ> boolean anyMatch(DoublePredicate predicate)
 ㄴ> boolean noneMatch(DoublePredicate predicate)
=> LongStream 메소드 // 생략

루핑
ㄴ forEach()
=> Iterator<T> 인터페이스의 디폴트 인스턴스 메소드이기도 하지만 Stream에서도 정의되어있고 기능이나 사용법이 다 동일하며 최종연산에 해당된다.
=> void forEach(Consumer<? super T> action)	// Stream<T>의 메소드
=> void forEach(IntConsumer action)		// IntStream의 메소드	
=> void forEach(DoubleConsumer action)	// DoubleStream의 메소드
=> void forEach(LongConsumer action)	// LongStream의 메소드

ㄴ collect
=> 필요하다면 파이프라인을 통해 가공되고 걸러진 데이터를 최종연산 과정에서 별도 저장해야한다면 이 메소드를 사용한다.
=> <R> R collect(Supplier<R> sup, BiConsumer<R, ? super T> accum, BiConsumer<R, R> combi)		// Stream<T>의 메소드
=> <R> R collect(Supplier<R> sup, ObjIntConsumer<R, ? super T> accum, BiConsumer<R, R> combi)		// IntStream의 메소드
=> <R> R collect(Supplier<R> sup, ObjLongConsumer<R, ? super T> accum, BiConsumer<R, R> combi)		// LongStream의 메소드
=> <R> R collect(Supplier<R> sup, ObjDoubleConsumer<R, ? super T> accum, BiConsumer<R, R> combi)	// DoubleStream의 메소드
=> 첫번째 매개변수로 전달되는 람다식은 데이터 저장소를 생성하는 람다식이다 					// ex) () -> new ArrayList<>()
=> 두번째 매개변수로 전달되는 람다식은 두개의 인자를 사용하는데 첫번째 인자는 앞에서 만든 새로운 데이터 	
     저장소이고 두번째 인자는 스트림의 데이터이다. 따라서 데이터를 저장소에 넣어주는 람다식을 작성하면 된다. 		// ex) (c, s) -> c.add(s)
=> 뒤의 세번째 인자는 병렬스트림이 아닌 순차스트림에서 사용되지 않는다 하지만 비워두면 안되기 때문에 인자 값을 채워둔다 // ex) (lst1, lst2) -> lst1.addAll(lst2)

5) 병렬스트림
-자바는 언어 차원에서 병렬처리를 지원한다. 따라서 쉽게 병렬처리를 진행할 수 있게 되었다
- 일반적 : stream() / 병렬 처리 : parallelStream() 
- CPU 코어 수를 고려하여 적절하게 병렬로 처리가 된다. 
- 둘 이상의 연산을 동시에 진행하기 때문에 연산의 단계를 줄일 수 있어서 속도 측면에서 이점을 얻을 수 있다. (연산의 횟수 X / 연산의 단계 O )
- 병렬 처리가 능사는 아니다. 병렬 처리를 했을 때 오히려 속도가 느려지는 경우도 의외로 많다. (병렬 처리를 위한 전후 과정이 더 소모적인 경우)
- 따라서 병렬 처리를 결정했을 때는 테스트를 통해서 적합성을 판단하고 실행해야한다.

- 병렬스트림으로 변경
ㄴ 이미 스트림을 생성한 상태에서 이를 기반으로 병렬 스트림으로 변경하길 원하는 경우
ㄴ BaseStream 인터페이스의 추상메소드
ㄴ Stream<T> parallel()
ㄴ DoubleStream parallel()
ㄴ IntStream parallel()
ㄴ LongStream parallel()

- 병렬 스트림에서의 collect
ㄴ 앞서 collect 메소드의 첫번째 인자와 두번째 인자에 대해서 설명하였다. 
ㄴ 3번째 인자는 앞서 첫번째와 두번째 람다식으로 저장이 끝난 저장소들을 하나로 묶는 과정을 거쳐야 하는데 이때 사용되는 것이 세번째 전달인자이다.
ㄴ (lst1, lst2) -> lst1.addAll(lst2) 에서 addAll은 첫번째 인자에서 만든 저장소(컬렉션 인스턴스)의 메소드로써, 메소드 호출결과로 lst2가 저장하고 있는 모든 데이터가 lst1에 담는다.

----------------------- 31 단원 : 시각과 날짜의 처리 ------------------------------------------

1) 시각과 날짜 관련 코드의 작성
- 시각 : 시간의 어느 한 지점 / 시간 : 어떤 시각에서 어떤 시각까지의 사이

- Instant 클래스
ㄴ 어느 한 시점(시각)을 나타내는 클래스
ㄴ 클래스 메소드
=> static Instant now() : now 메소드를 호출을 통한 Instant 인스턴스 생성 (현재 시각)
ㄴ 인스턴스 메소드 
=> public long getEpochSecond() : 1970-01-01-00:00:00을 기준으로 지금까지를 초단위로 계산한 결과

- Duration클래스
ㄴ 어느 한 시각과 한 시각 사이의 시각 차를 나타내는 클래스
ㄴ 클래스 메소드
=> static Duration between( Instant start, Instant end) : start 시각과 end 시각 사이의 시간을 구함
ㄴ 인스턴스 메소드
=> double toMillis() : 시간을 밀리초로 변환함

- LocalDate 클래스
ㄴ 날짜 정보를 표현하기 위한 클래스
ㄴ 클래스 메소드
=> pulbic static LocalDate now()	 : 오늘의 날짜 정보를 담은 LocalDate 인스턴스를 생성
=> public static LocalDate of(int year, int month, int dayOfMonth) : 년, 월, 일을 직접 입력해서 날짜 정보를 담은 LocalDate 인스턴스를 생성
ㄴ 인스턴스 메소드
=> pulbic LocalDate minusYears(long years) 	   : 현재 인스턴스에서 years만큼 년도를 뺀 LocalDate 인스턴스를 반환
=> pulbic LocalDate minusMonths(long months)  : 현재 인스턴스에서 months만큼 년도를 뺀 LocalDate 인스턴스를 반환
=> pulbic LocalDate minusDays(long days)	   : 현재 인스턴스에서 days만큼 년도를 뺀 LocalDate 인스턴스를 반환
=> pulbic LocalDate plusYears(long years)           : 현재 인스턴스에서 years만큼 년도를 더한 LocalDate 인스턴스를 반환
=> pulbic LocalDate plusMonths(long months)    : 현재 인스턴스에서 months만큼 년도를 더한 LocalDate 인스턴스를 반환
=> pulbic LocalDate plusDays(long days)  	   : 현재 인스턴스에서 days만큼 년도를 더한 LocalDate 인스턴스를 반환
=> public int getYears()			   : 현재 인스턴스의 년도를 반환
=> public int getMonths()			   : 현재 인스턴스의 월을 반환
=> public int getDays()			   : 현재 인스턴스의 일을 반환

- Period 클래스
ㄴ 날짜의 차를 표현하기 위한 클래스
ㄴ 클래스 메소드 
=> static Period between(LocalDate start, LocalDate end)        : start 날짜와 end 날짜의 날짜 차를 구함
ㄴ 인스턴스 메소드
=> public int getYear() 			: 현재 인스턴스의 저장된 년도 정보를 얻을 수 있음 
=> public int getMonthValue()		: 현재 인스턴스의 저장된 월 정보를 얻을 수 있음
=> public int getDayOfMonth()		: 현재 인스턴스의 저장된 일 정보를 얻을 수 있음

- LocalTime 클래스
ㄴ 시각 정보를 나타내는 클래스이다.
ㄴ 클래스 메소드
=> public static LocalTime now() 				: 지금 시간 정보를 담은 LocalTime 인스턴스를 생성
=> public static LocalTIme of(int hours, int minute, int seconds)	:
ㄴ 인스턴스 메소드
=> pulbic LocalTime plusHours(long hours)		: 현재 인스턴스에서 hours 만큼 년도를 더한 LocalTime 인스턴스를 반환 
=> pulbic LocalTime plusMinutes(long minutes)	: 현재 인스턴스에서 minutes 만큼 년도를 더한 LocalTime 인스턴스를 반환 
=> pulbic LocalTime plusSeconds(long seconds)	: 현재 인스턴스에서 seconds 만큼 년도를 더한 LocalTime 인스턴스를 반환 
=> pulbic LocalTime minusHours(long hours)		: 현재 인스턴스에서 hours 만큼 년도를 뺀 LocalTime 인스턴스를 반환 
=> pulbic LocalTime minusMinutes(long minutes)	: 현재 인스턴스에서 minutes 만큼 년도를 뺀 LocalTime 인스턴스를 반환 
=> pulbic LocalTime minusSeconds(long seconds)	: 현재 인스턴스에서 seconds 만큼 년도를 뺀 LocalTime 인스턴스를 반환 
=> public int getHour()				: 현재 인스턴스의 시 정보를 얻을 수 있음  
=> public int getMinute()				: 현재 인스턴스의 분 정보를 얻을 수 있음 
=> public int getSecond()				: 현재 인스턴스의 초 정보를 얻을 수 있음 
ㄴ localTime 클래스도 Instant 클래스와 같이 Duration 클래스를 주로 사용한다.
 
- LocalDateTime 클래스
ㄴ LocalDate와 LocalTime 클래스를 합친 클래스
ㄴ 클래스 메소드
=> public static LocalDateTime now() 			: 현재 날짜와 시간 정보를 담은 LocalDateTime 인스턴스를 생성
=> public static LocalDateTime of (int year, int month, int dayOfMonth, int hours, int minute, int second) 	: 원하는 년,월,일,시,분,초를 넣어서 LocalDateTime 인스턴스를 생성함
ㄴ 인스턴스 메소드
=> pulbic LocalDateTime plusYears(long years)           	: 현재 인스턴스에서 years만큼 년도를 더한 LocalDateTime 인스턴스를 반환
=> pulbic LocalDateTime plusMonths(long months)    	: 현재 인스턴스에서 months만큼 년도를 더한 LocalDateTime 인스턴스를 반환
=> pulbic LocalDateTime plusDays(long days)  	   	: 현재 인스턴스에서 days만큼 년도를 더한 LocalDateTime 인스턴스를 반환
=> pulbic LocalDateTime plusHours(long hours)	: 현재 인스턴스에서 hours 만큼 년도를 더한 LocalDateTime 인스턴스를 반환 
=> pulbic LocalDateTime plusMinutes(long minutes)	: 현재 인스턴스에서 minutes 만큼 년도를 더한 LocalDateTime 인스턴스를 반환 
=> pulbic LocalDateTime plusSeconds(long seconds)	: 현재 인스턴스에서 seconds 만큼 년도를 더한 LocalDateTime 인스턴스를 반환 
=> pulbic LocalDateTime minusYears(long years) 	: 현재 인스턴스에서 years만큼 년도를 뺀 LocalDateTime 인스턴스를 반환
=> pulbic LocalDateTime minusMonths(long months)  	: 현재 인스턴스에서 months만큼 년도를 뺀 LocalDateTime 인스턴스를 반환
=> pulbic LocalDateTime minusDays(long days)	   	: 현재 인스턴스에서 days만큼 년도를 뺀 LocalDateTime 인스턴스를 반환
=> pulbic LocalDateTime minusHours(long hours)	: 현재 인스턴스에서 hours 만큼 년도를 뺀 LocalDateTime 인스턴스를 반환 
=> pulbic LocalDateTime minusMinutes(long minutes)	: 현재 인스턴스에서 minutes 만큼 년도를 뺀 LocalDateTime 인스턴스를 반환 
=> pulbic LocalDateTime minusSeconds(long seconds)	: 현재 인스턴스에서 seconds 만큼 년도를 뺀 LocalDateTime 인스턴스를 반환 
=> public int getYears()			   	: 현재 인스턴스의 년도를 반환
=> public int getMonths()			   	: 현재 인스턴스의 월을 반환
=> public int getDays()			   	: 현재 인스턴스의 일을 반환
=> public int getHour()				: 현재 인스턴스의 시 정보를 얻을 수 있음  
=> public int getMinute()				: 현재 인스턴스의 분 정보를 얻을 수 있음 
=> public int getSecond()				: 현재 인스턴스의 초 정보를 얻을 수 있음 
=> public boolean isbefore(LocalDateTime l)		: 현재 인스턴스와 인자로 받아진 인스턴스의 날짜와 시간이 어느것이 더 앞서는 지 true와 false로 반환 (현재 인스턴스가 앞서면 true)
=> publc boolean isAfter(LocalDateTime l)		: 현재 인스턴스와 인자로 받아진 인스턴스의 날짜와 시간이 어느것이 더 후에 있는지 true와 false로 반환 (현재 인스턴스가 뒤면 true)
=> public LocalDate toLocalDate()			: 현재 인스턴스에서 날짜에 대한 정보를 LocalDate 인스턴스에 담아서 반환
=> public LocalTime toLocalTime()			: 현재 인스턴스에서 시각에 대한 정보를 LocalTime 인스턴스에 담아서 반환
ㄴ 날짜 차와 시각 차를 따로 구해야한다. (Period / Duration)

Months 클래스에 열거형으로 1 ~ 12월이 정의되어 있다. (JANUARY ... DECEMBER)

2) 시간대를 적용한 코드 작성 그리고 출력 포맷의 지정
- 세계의 시간대 :시차는 1972년 1월 1일부로 시행된 세계적인 약속 => 협정세계시(UTC) // 한국의 시간대는 UTC +9

- 시간대를 표현하는 ZoneId 클래스
ㄴ 특정 시간대를 반영하는 코드를 작성하려면 그에 맞는 ZoneId 인스턴스를 생성해야한다.
ㄴ 클래스 메소드 
=> public staitc ZoneId of(String zone) : 특정 지역의 zone을 입력해서 ZoneId 인스턴스 생성
=> public static set<String> getAvailableZoneIds() : ZoneId 내의 모든 Zone을 반환함

- 시간대를 반영한 ZonedDateTime
ㄴ LocalDateTime 클래스는 시간대 정보를 갖지 않는다. 반면 ZonedDateTime 클래스는 인스턴스 별로 시간대 정보를 다르게 지정할 수 있다.
ㄴ 지역간의 시차를 구할 때 유용하다. Duration의 between 메소드는 두 지역간의 시차까지 고려해서 시간 계산을 가능하게 해준다.
ㄴ 클래스 메소드
=> public static ZonedDateTime now()				: 현재 위치에서의 날짜와 시간 정보를 담아 ZonedDateTime 인스턴스를 생성
=> public static ZonedDateTime of(LocalDateTime ldt, ZoneId zone)	: 현재 위치에서의 날짜와 시간 정보(LocalDateTime)와 ZoneId 인스턴스를 담아 ZonedDateTime 인스턴스를 생성
=> public static ZonedDateTime of(int year, int month, int datOfMonth, int hour, int minute, int second, int nanoOfSecond ZoneId zone)	: 원하는 날짜와 시간 정보와 ZoneId 인스턴스를 담아 ZonedDateTime 인스턴스를 생성

- 날짜와 시각 정보의 출력 포맷 지정 DateTimeFormatter 클래스
ㄴ 위의 클래스들은 데이터 포맷팅하는 메소드를 지님 (LocalDate, LocalTime, LocalDateTime, ZonedDateTime)
=> public String format(DateTimeFormatter formatter) 		: DateTimeFormatter 인스턴스를 인자로 받아서 그 로직대로 날짜/시간 데이터를 포맷팅함
ㄴjava.time.format.DateTimeFormatter
ㄴ 클래스 메소드
=> public static DateTimeFormatter ofPattern(String pattern)	: String을 인자로 받아 그 인자대로 DateTimeFormatter 인스턴스를 생성함
=> ex) "yy-M-d" / "yyyy-MM-d, H:m:s" / "yyyy-MM-dd, HH:mm:ss VV"	=> 일부러 두자리를 채운 것은 0을 유효하게 쓰겠다는 말임 / 덜 채운것은 생략하겠다는 의미

----------------------- 32 단원 : I/O 스트림 ----------------------------------------------------

----------------------- 33 단원 : NIO 그리고 NIO.2 --------------------------------------------

----------------------- 34 단원 : 쓰레드 그리고 동기화 ----------------------------------------
